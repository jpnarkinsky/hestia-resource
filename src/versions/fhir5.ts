// Autogenerated by src/generate.  Do not edit!
namespace fhir5 {
  export type TElement =
    | string
    | number
    | boolean
    | Address
    | Address[]
    | Age
    | Age[]
    | Annotation
    | Annotation[]
    | Attachment
    | Attachment[]
    | Availability
    | Availability[]
    | BackboneElement
    | BackboneElement[]
    | BackboneType
    | BackboneType[]
    | Base
    | Base[]
    | Base64Binary
    | Base64Binary[]
    | Boolean
    | Boolean[]
    | Canonical
    | Canonical[]
    | Code
    | Code[]
    | CodeableConcept
    | CodeableConcept[]
    | CodeableReference
    | CodeableReference[]
    | Coding
    | Coding[]
    | ContactDetail
    | ContactDetail[]
    | ContactPoint
    | ContactPoint[]
    | Contributor
    | Contributor[]
    | Count
    | Count[]
    | DataRequirement
    | DataRequirement[]
    | DataType
    | DataType[]
    | Date
    | Date[]
    | DateTime
    | DateTime[]
    | Decimal
    | Decimal[]
    | Distance
    | Distance[]
    | Dosage
    | Dosage[]
    | Duration
    | Duration[]
    | Element
    | Element[]
    | ElementDefinition
    | ElementDefinition[]
    | Expression
    | Expression[]
    | ExtendedContactDetail
    | ExtendedContactDetail[]
    | Extension
    | Extension[]
    | HumanName
    | HumanName[]
    | Id
    | Id[]
    | Identifier
    | Identifier[]
    | Instant
    | Instant[]
    | Integer
    | Integer[]
    | Integer64
    | Integer64[]
    | Markdown
    | Markdown[]
    | MarketingStatus
    | MarketingStatus[]
    | Meta
    | Meta[]
    | MonetaryComponent
    | MonetaryComponent[]
    | Money
    | Money[]
    | MoneyQuantity
    | MoneyQuantity[]
    | Narrative
    | Narrative[]
    | Oid
    | Oid[]
    | ParameterDefinition
    | ParameterDefinition[]
    | Period
    | Period[]
    | PositiveInt
    | PositiveInt[]
    | PrimitiveType
    | PrimitiveType[]
    | ProductShelfLife
    | ProductShelfLife[]
    | Quantity
    | Quantity[]
    | Range
    | Range[]
    | Ratio
    | Ratio[]
    | RatioRange
    | RatioRange[]
    | Reference
    | Reference[]
    | RelatedArtifact
    | RelatedArtifact[]
    | SampledData
    | SampledData[]
    | Signature
    | Signature[]
    | SimpleQuantity
    | SimpleQuantity[]
    | String
    | String[]
    | Time
    | Time[]
    | Timing
    | Timing[]
    | TriggerDefinition
    | TriggerDefinition[]
    | UnsignedInt
    | UnsignedInt[]
    | Uri
    | Uri[]
    | Url
    | Url[]
    | UsageContext
    | UsageContext[]
    | Uuid
    | Uuid[]
    | VirtualServiceDetail
    | VirtualServiceDetail[]
    | Xhtml
    | Xhtml[];

  /** Root of fhir class hierarchy */
  abstract class Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Base";
    protected _content: { [key: string]: TElement } = {};

    /**
     * Base class for all data elements
     *
     * @_content {Object} value
     */
    constructor(content: { [key: string]: TElement }) {
      Object.assign(this._content, content);
      this._content.resourceType = this.constructor.name;
    }
  }

  /** Base class for all data elements */
  abstract class Element extends Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Element";
  }

  abstract class DataType extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/DataType";
  }

  abstract class Resource extends Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Resource";
  }

  /**
   * BackboneElement Type: Base definition for all elements that are defined
   * inside a resource - but not those in a data type.
   */
  export abstract class BackboneElement extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/BackboneElement";

    /**
     * May be used to represent additional information that is not part of the
     * basic definition of the element and that modifies the understanding of
     * the element in which it is contained and/or the understanding of the
     * containing element's descendants. Usually modifier elements provide
     * negation or qualification. To make the use of extensions safe and
     * managable, there is a strict set of governance applied to the definition
     * and use of extensions. Though any implementer can define an extension,
     * there is a set of requirements that SHALL be met as part of the
     * definition of the extension. Applications processing a resource are
     * required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    set modifierExtension(value: Array<Extension>) {
      this._content["modifierExtension"] = value;
    }

    get modifierExtension(): Array<Extension> {
      return this._content["modifierExtension"] as Array<Extension>;
    }
  }

  /**
   * BackboneType Type: Base definition for the few data types that are allowed
   * to carry modifier extensions.
   */
  export abstract class BackboneType extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/BackboneType";

    /**
     * May be used to represent additional information that is not part of the
     * basic definition of the element and that modifies the understanding of
     * the element in which it is contained and/or the understanding of the
     * containing element's descendants. Usually modifier elements provide
     * negation or qualification. To make the use of extensions safe and
     * managable, there is a strict set of governance applied to the definition
     * and use of extensions. Though any implementer can define an extension,
     * there is a set of requirements that SHALL be met as part of the
     * definition of the extension. Applications processing a resource are
     * required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    set modifierExtension(value: Array<Extension>) {
      this._content["modifierExtension"] = value;
    }

    get modifierExtension(): Array<Extension> {
      return this._content["modifierExtension"] as Array<Extension>;
    }
  }

  /**
   * PrimitiveType Type: The base type for all re-useable types defined that
   * have a simple property.
   */
  export abstract class PrimitiveType extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/PrimitiveType";
  }

  /** A resource that includes narrative, extensions, and contained resources. */
  export abstract class DomainResource extends Resource {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/DomainResource";

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * nor can they have their own independent transaction scope. This is
     * allowed to be a Parameters resource if and only if it is referenced by a
     * resource that provides context/meaning.
     */
    set contained(value: Array<Resource>) {
      this._content["contained"] = value;
    }

    get contained(): Array<Resource> {
      return this._content["contained"] as Array<Resource>;
    }

    /**
     * May be used to represent additional information that is not part of the
     * basic definition of the resource. To make the use of extensions safe and
     * managable, there is a strict set of governance applied to the definition
     * and use of extensions. Though any implementer can define an extension,
     * there is a set of requirements that SHALL be met as part of the
     * definition of the extension.
     */
    set extension(value: Array<Extension>) {
      this._content["extension"] = value;
    }

    get extension(): Array<Extension> {
      return this._content["extension"] as Array<Extension>;
    }

    /**
     * May be used to represent additional information that is not part of the
     * basic definition of the resource and that modifies the understanding of
     * the element that contains it and/or the understanding of the containing
     * element's descendants. Usually modifier elements provide negation or
     * qualification. To make the use of extensions safe and managable, there is
     * a strict set of governance applied to the definition and use of
     * extensions. Though any implementer is allowed to define an extension,
     * there is a set of requirements that SHALL be met as part of the
     * definition of the extension. Applications processing a resource are
     * required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    set modifierExtension(value: Array<Extension>) {
      this._content["modifierExtension"] = value;
    }

    get modifierExtension(): Array<Extension> {
      return this._content["modifierExtension"] as Array<Extension>;
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it "clinically safe" for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    set text(value: Narrative) {
      this._content["text"] = value;
    }

    get text(): Narrative {
      return this._content["text"] as Narrative;
    }
  }

  /**
   * Common Interface declaration for conformance and knowledge artifact
   * resources.
   */
  export abstract class CanonicalResource extends DomainResource {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/CanonicalResource";

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    set contact(value: Array<ContactDetail>) {
      this._content["contact"] = value;
    }

    get contact(): Array<ContactDetail> {
      return this._content["contact"] as Array<ContactDetail>;
    }

    /**
     * A copyright statement relating to the {{title}} and/or its contents.
     * Copyright statements are generally legal restrictions on the use and
     * publishing of the {{title}}.
     */
    set copyright(value: Markdown) {
      this._content["copyright"] = value;
    }

    get copyright(): Markdown {
      return this._content["copyright"] as Markdown;
    }

    /**
     * A short string (<50 characters), suitable for inclusion in a page footer
     * that identifies the copyright holder, effective period, and optionally
     * whether rights are resctricted. (e.g. 'All rights reserved', 'Some rights
     * reserved').
     */
    set copyrightLabel(value: String) {
      this._content["copyrightLabel"] = value;
    }

    get copyrightLabel(): String {
      return this._content["copyrightLabel"] as String;
    }

    /**
     * The date (and optionally time) when the {{title}} was last significantly
     * changed. The date must change when the business version changes and it
     * must change if the status code changes. In addition, it should change
     * when the substantive content of the {{title}} changes.
     */
    set date(value: DateTime) {
      this._content["date"] = value;
    }

    get date(): DateTime {
      return this._content["date"] as DateTime;
    }

    /**
     * A free text natural language description of the {{title}} from a
     * consumer's perspective.
     */
    set description(value: Markdown) {
      this._content["description"] = value;
    }

    get description(): Markdown {
      return this._content["description"] as Markdown;
    }

    /**
     * A Boolean value to indicate that this {{title}} is authored for testing
     * purposes (or education/evaluation/marketing) and is not intended for
     * genuine usage.
     */
    set experimental(value: Boolean) {
      this._content["experimental"] = value;
    }

    get experimental(): Boolean {
      return this._content["experimental"] as Boolean;
    }

    /**
     * A formal identifier that is used to identify this {{title}} when it is
     * represented in other formats, or referenced in a specification, model,
     * design or an instance.
     */
    set identifier(value: Array<Identifier>) {
      this._content["identifier"] = value;
    }

    get identifier(): Array<Identifier> {
      return this._content["identifier"] as Array<Identifier>;
    }

    /**
     * A legal or geographic region in which the {{title}} is intended to be
     * used.
     */
    set jurisdiction(value: Array<CodeableConcept>) {
      this._content["jurisdiction"] = value;
    }

    get jurisdiction(): Array<CodeableConcept> {
      return this._content["jurisdiction"] as Array<CodeableConcept>;
    }

    /**
     * A natural language name identifying the {{title}}. This name should be
     * usable as an identifier for the resource by machine processing
     * applications such as code generation.
     */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /**
     * The name of the organization or individual responsible for the release
     * and ongoing maintenance of the {{title}}.
     */
    set publisher(value: String) {
      this._content["publisher"] = value;
    }

    get publisher(): String {
      return this._content["publisher"] as String;
    }

    /**
     * Explanation of why this {{title}} is needed and why it has been designed
     * as it has.
     */
    set purpose(value: Markdown) {
      this._content["purpose"] = value;
    }

    get purpose(): Markdown {
      return this._content["purpose"] as Markdown;
    }

    /** The current state of this {{title}}. */
    set status(value: Code) {
      this._content["status"] = value;
    }

    get status(): Code {
      return this._content["status"] as Code;
    }

    /** A short, descriptive, user-friendly title for the {{title}}. */
    set title(value: String) {
      this._content["title"] = value;
    }

    get title(): String {
      return this._content["title"] as String;
    }

    /**
     * An absolute URI that is used to identify this {{title}} when it is
     * referenced in a specification, model, design or an instance; also called
     * its canonical identifier. This SHOULD be globally unique and SHOULD be a
     * literal address at which an authoritative instance of this {{title}} is
     * (or will be) published. This URL can be the target of a canonical
     * reference. It SHALL remain the same when the {{title}} is stored on
     * different servers.
     */
    set url(value: Uri) {
      this._content["url"] = value;
    }

    get url(): Uri {
      return this._content["url"] as Uri;
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs (insurance
     * plans, studies, ...) and may be used to assist with indexing and
     * searching for appropriate {{title}}s.
     */
    set useContext(value: Array<UsageContext>) {
      this._content["useContext"] = value;
    }

    get useContext(): Array<UsageContext> {
      return this._content["useContext"] as Array<UsageContext>;
    }

    /**
     * The identifier that is used to identify this version of the {{title}}
     * when it is referenced in a specification, model, design or instance. This
     * is an arbitrary value managed by the {{title}} author and is not expected
     * to be globally unique. For example, it might be a timestamp (e.g.
     * yyyymmdd) if a managed version is not available. There is also no
     * expectation that versions can be placed in a lexicographical sequence
     * without additional knowledge. (See the versionAlgorithm element.)
     */
    set version(value: String) {
      this._content["version"] = value;
    }

    get version(): String {
      return this._content["version"] as String;
    }

    /**
     * Indicates the mechanism used to compare versions to determine which is
     * more current.
     */
    set versionAlgorithm(value: String | Coding) {
      this._content["versionAlgorithm"] = value;
    }

    get versionAlgorithmString(): String {
      return this._content["versionAlgorithm"] as String;
    }

    get versionAlgorithmCoding(): Coding {
      return this._content["versionAlgorithm"] as Coding;
    }
  }

  /**
   * Common Interface declaration for conformance and knowledge artifact
   * resources.
   */
  export abstract class MetadataResource extends DomainResource {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MetadataResource";

    /**
     * The date on which the resource content was approved by the publisher.
     * Approval happens once when the content is officially approved for usage.
     */
    set approvalDate(value: Date) {
      this._content["approvalDate"] = value;
    }

    get approvalDate(): Date {
      return this._content["approvalDate"] as Date;
    }

    /**
     * An individiual or organization primarily involved in the creation and
     * maintenance of the {{title}}.
     */
    set author(value: Array<ContactDetail>) {
      this._content["author"] = value;
    }

    get author(): Array<ContactDetail> {
      return this._content["author"] as Array<ContactDetail>;
    }

    /**
     * An individual or organization primarily responsible for internal
     * coherence of the {{title}}.
     */
    set editor(value: Array<ContactDetail>) {
      this._content["editor"] = value;
    }

    get editor(): Array<ContactDetail> {
      return this._content["editor"] as Array<ContactDetail>;
    }

    /**
     * The period during which the {{title}} content was or is planned to be in
     * active use.
     */
    set effectivePeriod(value: Period) {
      this._content["effectivePeriod"] = value;
    }

    get effectivePeriod(): Period {
      return this._content["effectivePeriod"] as Period;
    }

    /**
     * An individual or organization asserted by the publisher to be responsible
     * for officially endorsing the {{title}} for use in some setting.
     */
    set endorser(value: Array<ContactDetail>) {
      this._content["endorser"] = value;
    }

    get endorser(): Array<ContactDetail> {
      return this._content["endorser"] as Array<ContactDetail>;
    }

    /**
     * The date on which the resource content was last reviewed. Review happens
     * periodically after approval but does not change the original approval
     * date.
     */
    set lastReviewDate(value: Date) {
      this._content["lastReviewDate"] = value;
    }

    get lastReviewDate(): Date {
      return this._content["lastReviewDate"] as Date;
    }

    /**
     * Related artifacts such as additional documentation, justification,
     * dependencies, bibliographic references, and predecessor and successor
     * artifacts.
     */
    set relatedArtifact(value: Array<RelatedArtifact>) {
      this._content["relatedArtifact"] = value;
    }

    get relatedArtifact(): Array<RelatedArtifact> {
      return this._content["relatedArtifact"] as Array<RelatedArtifact>;
    }

    /**
     * An individual or organization asserted by the publisher to be primarily
     * responsible for review of some aspect of the {{title}}.
     */
    set reviewer(value: Array<ContactDetail>) {
      this._content["reviewer"] = value;
    }

    get reviewer(): Array<ContactDetail> {
      return this._content["reviewer"] as Array<ContactDetail>;
    }

    /**
     * Descriptive topics related to the content of the {{title}}. Topics
     * provide a high-level categorization as well as keywords for the {{title}}
     * that can be useful for filtering and searching.
     */
    set topic(value: Array<CodeableConcept>) {
      this._content["topic"] = value;
    }

    get topic(): Array<CodeableConcept> {
      return this._content["topic"] as Array<CodeableConcept>;
    }
  }

  class Base64Binary extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/base64Binary";
  }

  class Boolean extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/boolean";
  }

  class Uri extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/uri";
  }

  class Canonical extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/canonical";
  }

  class String extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/string";
  }

  class Code extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/code";
  }

  class Date extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/date";
  }

  class DateTime extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/dateTime";
  }

  class Decimal extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/decimal";
  }

  class Id extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/id";
  }

  class Instant extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/instant";
  }

  class Integer extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/integer";
  }

  class Integer64 extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/integer64";
  }

  class Markdown extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/markdown";
  }

  class Oid extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/oid";
  }

  class PositiveInt extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/positiveInt";
  }

  class Time extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/time";
  }

  class UnsignedInt extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/unsignedInt";
  }

  class Url extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/url";
  }

  class Uuid extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/uuid";
  }

  class Xhtml extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/xhtml";
  }

  /**
   * Address Type: An address expressed using postal conventions (as opposed to
   * GPS or other location definition formats). This data type may be used to
   * convey addresses for use in delivering mail as well as for visiting
   * locations which might not be valid for mail delivery. There are a variety
   * of postal address formats defined around the world. The
   * ISO21090-codedString may be used to provide a coded representation of the
   * contents of strings in an Address.
   */
  export class Address extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Address";

    /**
     * The name of the city, town, suburb, village or other community or
     * delivery center.
     */
    set city(value: String) {
      this._content["city"] = value;
    }

    get city(): String {
      return this._content["city"] as String;
    }

    /** Country - a nation as commonly understood or generally accepted. */
    set country(value: String) {
      this._content["country"] = value;
    }

    get country(): String {
      return this._content["country"] as String;
    }

    /** The name of the administrative area (county). */
    set district(value: String) {
      this._content["district"] = value;
    }

    get district(): String {
      return this._content["district"] as String;
    }

    /**
     * This component contains the house number, apartment number, street name,
     * street direction, P.O. Box number, delivery hints, and similar address
     * information.
     */
    set line(value: Array<String>) {
      this._content["line"] = value;
    }

    get line(): Array<String> {
      return this._content["line"] as Array<String>;
    }

    /** Time period when address was/is in use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /** A postal code designating a region defined by the postal service. */
    set postalCode(value: String) {
      this._content["postalCode"] = value;
    }

    get postalCode(): String {
      return this._content["postalCode"] as String;
    }

    /**
     * Sub-unit of a country with limited sovereignty in a federally organized
     * country. A code may be used if codes are in common use (e.g. US 2 letter
     * state codes).
     */
    set state(value: String) {
      this._content["state"] = value;
    }

    get state(): String {
      return this._content["state"] as String;
    }

    /**
     * Specifies the entire address as it should be displayed e.g. on a postal
     * label. This may be provided instead of or as well as the specific parts.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /**
     * Distinguishes between physical addresses (those you can visit) and
     * mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses
     * are both.
     */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /** The purpose of this address. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Quantity Type: A measured amount (or an amount that can potentially be
   * measured). Note that measured amounts include amounts that are not
   * precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  export class Quantity extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Quantity";

    /**
     * A computer processable form of the unit in some unit representation
     * system.
     */
    set code(value: Code) {
      this._content["code"] = value;
    }

    get code(): Code {
      return this._content["code"] as Code;
    }

    /**
     * How the value should be understood and represented - whether the actual
     * value is greater or less than the stated value due to measurement issues;
     * e.g. if the comparator is "<" , then the real value is < stated value.
     */
    set comparator(value: Code) {
      this._content["comparator"] = value;
    }

    get comparator(): Code {
      return this._content["comparator"] as Code;
    }

    /**
     * The identification of the system that provides the coded form of the
     * unit.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /** A human-readable form of the unit. */
    set unit(value: String) {
      this._content["unit"] = value;
    }

    get unit(): String {
      return this._content["unit"] as String;
    }

    /**
     * The value of the measured amount. The value includes an implicit
     * precision in the presentation of the value.
     */
    set value(value: Decimal) {
      this._content["value"] = value;
    }

    get value(): Decimal {
      return this._content["value"] as Decimal;
    }
  }

  /**
   * Age Type: A duration of time during which an organism (or a process) has
   * existed.
   */
  export class Age extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Age";
  }

  /**
   * Annotation Type: A text note which also contains information about who made
   * the statement and when.
   */
  export class Annotation extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Annotation";

    /** The individual responsible for making the annotation. */
    set author(value: Reference | String) {
      this._content["author"] = value;
    }

    get authorReference(): Reference {
      return this._content["author"] as Reference;
    }

    get authorString(): String {
      return this._content["author"] as String;
    }

    /** The text of the annotation in markdown format. */
    set text(value: Markdown) {
      this._content["text"] = value;
    }

    get text(): Markdown {
      return this._content["text"] as Markdown;
    }

    /** Indicates when this particular annotation was made. */
    set time(value: DateTime) {
      this._content["time"] = value;
    }

    get time(): DateTime {
      return this._content["time"] as DateTime;
    }
  }

  /** Attachment Type: For referring to data content defined in other formats. */
  export class Attachment extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Attachment";

    /**
     * Identifies the type of the data in the attachment and allows a method to
     * be chosen to interpret or render the data. Includes mime type parameters
     * such as charset where appropriate.
     */
    set contentType(value: Code) {
      this._content["contentType"] = value;
    }

    get contentType(): Code {
      return this._content["contentType"] as Code;
    }

    /** The date that the attachment was first created. */
    set creation(value: DateTime) {
      this._content["creation"] = value;
    }

    get creation(): DateTime {
      return this._content["creation"] as DateTime;
    }

    /** The actual data of the attachment - a sequence of bytes, base64 encoded. */
    set data(value: Base64Binary) {
      this._content["data"] = value;
    }

    get data(): Base64Binary {
      return this._content["data"] as Base64Binary;
    }

    /** The duration of the recording in seconds - for audio and video. */
    set duration(value: Decimal) {
      this._content["duration"] = value;
    }

    get duration(): Decimal {
      return this._content["duration"] as Decimal;
    }

    /**
     * The number of frames in a photo. This is used with a multi-page fax, or
     * an imaging acquisition context that takes multiple slices in a single
     * image, or an animated gif. If there is more than one frame, this SHALL
     * have a value in order to alert interface software that a multi-frame
     * capable rendering widget is required.
     */
    set frames(value: PositiveInt) {
      this._content["frames"] = value;
    }

    get frames(): PositiveInt {
      return this._content["frames"] as PositiveInt;
    }

    /** The calculated hash of the data using SHA-1. Represented using base64. */
    set hash(value: Base64Binary) {
      this._content["hash"] = value;
    }

    get hash(): Base64Binary {
      return this._content["hash"] as Base64Binary;
    }

    /** Height of the image in pixels (photo/video). */
    set height(value: PositiveInt) {
      this._content["height"] = value;
    }

    get height(): PositiveInt {
      return this._content["height"] as PositiveInt;
    }

    /**
     * The human language of the content. The value can be any valid value
     * according to BCP 47.
     */
    set language(value: Code) {
      this._content["language"] = value;
    }

    get language(): Code {
      return this._content["language"] as Code;
    }

    /** The number of pages when printed. */
    set pages(value: PositiveInt) {
      this._content["pages"] = value;
    }

    get pages(): PositiveInt {
      return this._content["pages"] as PositiveInt;
    }

    /**
     * The number of bytes of data that make up this attachment (before base64
     * encoding, if that is done).
     */
    set size(value: Integer64) {
      this._content["size"] = value;
    }

    get size(): Integer64 {
      return this._content["size"] as Integer64;
    }

    /** A label or set of text to display in place of the data. */
    set title(value: String) {
      this._content["title"] = value;
    }

    get title(): String {
      return this._content["title"] as String;
    }

    /** A location where the data can be accessed. */
    set url(value: Url) {
      this._content["url"] = value;
    }

    get url(): Url {
      return this._content["url"] as Url;
    }

    /** Width of the image in pixels (photo/video). */
    set width(value: PositiveInt) {
      this._content["width"] = value;
    }

    get width(): PositiveInt {
      return this._content["width"] as PositiveInt;
    }
  }

  /** Availability Type: Availability data for an {item}. */
  export class Availability extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Availability";

    /** Times the {item} is available. */
    set availableTime(value: Array<Element>) {
      this._content["availableTime"] = value;
    }

    get availableTime(): Array<Element> {
      return this._content["availableTime"] as Array<Element>;
    }

    /** Not available during this time due to provided reason. */
    set notAvailableTime(value: Array<Element>) {
      this._content["notAvailableTime"] = value;
    }

    get notAvailableTime(): Array<Element> {
      return this._content["notAvailableTime"] as Array<Element>;
    }
  }

  /**
   * CodeableConcept Type: A concept that may be defined by a formal reference
   * to a terminology or ontology or may be provided by text.
   */
  export class CodeableConcept extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/CodeableConcept";

    /** A reference to a code defined by a terminology system. */
    set coding(value: Array<Coding>) {
      this._content["coding"] = value;
    }

    get coding(): Array<Coding> {
      return this._content["coding"] as Array<Coding>;
    }

    /**
     * A human language representation of the concept as seen/selected/uttered
     * by the user who entered the data and/or which represents the intended
     * meaning of the user.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }
  }

  /**
   * CodeableReference Type: A reference to a resource (by instance), or
   * instead, a reference to a concept defined in a terminology or ontology (by
   * class).
   */
  export class CodeableReference extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/CodeableReference";

    /**
     * A reference to a concept - e.g. the information is identified by its
     * general class to the degree of precision found in the terminology.
     */
    set concept(value: CodeableConcept) {
      this._content["concept"] = value;
    }

    get concept(): CodeableConcept {
      return this._content["concept"] as CodeableConcept;
    }

    /**
     * A reference to a resource the provides exact details about the
     * information being referenced.
     */
    set reference(value: Reference) {
      this._content["reference"] = value;
    }

    get reference(): Reference {
      return this._content["reference"] as Reference;
    }
  }

  /** Coding Type: A reference to a code defined by a terminology system. */
  export class Coding extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Coding";

    /**
     * A symbol in syntax defined by the system. The symbol may be a predefined
     * code or an expression in a syntax defined by the coding system (e.g.
     * post-coordination).
     */
    set code(value: Code) {
      this._content["code"] = value;
    }

    get code(): Code {
      return this._content["code"] as Code;
    }

    /**
     * A representation of the meaning of the code in the system, following the
     * rules of the system.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * The identification of the code system that defines the meaning of the
     * symbol in the code.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /**
     * Indicates that this coding was chosen by a user directly - e.g. off a
     * pick list of available items (codes or displays).
     */
    set userSelected(value: Boolean) {
      this._content["userSelected"] = value;
    }

    get userSelected(): Boolean {
      return this._content["userSelected"] as Boolean;
    }

    /**
     * The version of the code system which was used when choosing this code.
     * Note that a well-maintained code system does not need the version
     * reported, because the meaning of codes is consistent across versions.
     * However this cannot consistently be assured, and when the meaning is not
     * guaranteed to be consistent, the version SHOULD be exchanged.
     */
    set version(value: String) {
      this._content["version"] = value;
    }

    get version(): String {
      return this._content["version"] as String;
    }
  }

  /**
   * ContactDetail Type: Specifies contact information for a person or
   * organization.
   */
  export class ContactDetail extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ContactDetail";

    /** The name of an individual to contact. */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /**
     * The contact details for the individual (if a name was provided) or the
     * organization.
     */
    set telecom(value: Array<ContactPoint>) {
      this._content["telecom"] = value;
    }

    get telecom(): Array<ContactPoint> {
      return this._content["telecom"] as Array<ContactPoint>;
    }
  }

  /**
   * ContactPoint Type: Details for all kinds of technology mediated contact
   * points for a person or organization, including telephone, email, etc.
   */
  export class ContactPoint extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/ContactPoint";

    /** Time period when the contact point was/is in use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Specifies a preferred order in which to use a set of contacts.
     * ContactPoints with lower rank values are more preferred than those with
     * higher rank values.
     */
    set rank(value: PositiveInt) {
      this._content["rank"] = value;
    }

    get rank(): PositiveInt {
      return this._content["rank"] as PositiveInt;
    }

    /**
     * Telecommunications form for contact point - what communications system is
     * required to make use of the contact.
     */
    set system(value: Code) {
      this._content["system"] = value;
    }

    get system(): Code {
      return this._content["system"] as Code;
    }

    /** Identifies the purpose for the contact point. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }

    /**
     * The actual contact point details, in a form that is meaningful to the
     * designated communication system (i.e. phone number or email address).
     */
    set value(value: String) {
      this._content["value"] = value;
    }

    get value(): String {
      return this._content["value"] as String;
    }
  }

  /**
   * Contributor Type: A contributor to the content of a knowledge asset,
   * including authors, editors, reviewers, and endorsers.
   */
  export class Contributor extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Contributor";

    /**
     * Contact details to assist a user in finding and communicating with the
     * contributor.
     */
    set contact(value: Array<ContactDetail>) {
      this._content["contact"] = value;
    }

    get contact(): Array<ContactDetail> {
      return this._content["contact"] as Array<ContactDetail>;
    }

    /**
     * The name of the individual or organization responsible for the
     * contribution.
     */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /** The type of contributor. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * Count Type: A measured amount (or an amount that can potentially be
   * measured). Note that measured amounts include amounts that are not
   * precisely quantified, including amounts involving arbitrary units and
   * floating currencies.
   */
  export class Count extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Count";
  }

  /**
   * DataRequirement Type: Describes a required data item for evaluation in
   * terms of the type of data, and optional code or date-based filters of the
   * data.
   */
  export class DataRequirement extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/DataRequirement";

    /**
     * Code filters specify additional constraints on the data, specifying the
     * value set of interest for a particular element of the data. Each code
     * filter defines an additional constraint on the data, i.e. code filters
     * are AND'ed, not OR'ed.
     */
    set codeFilter(value: Array<Element>) {
      this._content["codeFilter"] = value;
    }

    get codeFilter(): Array<Element> {
      return this._content["codeFilter"] as Array<Element>;
    }

    /**
     * Date filters specify additional constraints on the data in terms of the
     * applicable date range for specific elements. Each date filter specifies
     * an additional constraint on the data, i.e. date filters are AND'ed, not
     * OR'ed.
     */
    set dateFilter(value: Array<Element>) {
      this._content["dateFilter"] = value;
    }

    get dateFilter(): Array<Element> {
      return this._content["dateFilter"] as Array<Element>;
    }

    /**
     * Specifies a maximum number of results that are required (uses the _count
     * search parameter).
     */
    set limit(value: PositiveInt) {
      this._content["limit"] = value;
    }

    get limit(): PositiveInt {
      return this._content["limit"] as PositiveInt;
    }

    /**
     * Indicates that specific elements of the type are referenced by the
     * knowledge module and must be supported by the consumer in order to obtain
     * an effective evaluation. This does not mean that a value is required for
     * this element, only that the consuming system must understand the element
     * and be able to provide values for it if they are available.
     *
     * The value of mustSupport SHALL be a FHIRPath resolvable on the type of
     * the DataRequirement. The path SHALL consist only of identifiers, constant
     * indexers, and .resolve() (see the [Simple FHIRPath
     * Profile](fhirpath.html#simple) for full details).
     */
    set mustSupport(value: Array<String>) {
      this._content["mustSupport"] = value;
    }

    get mustSupport(): Array<String> {
      return this._content["mustSupport"] as Array<String>;
    }

    /**
     * The profile of the required data, specified as the uri of the profile
     * definition.
     */
    set profile(value: Array<Canonical>) {
      this._content["profile"] = value;
    }

    get profile(): Array<Canonical> {
      return this._content["profile"] as Array<Canonical>;
    }

    /** Specifies the order of the results to be returned. */
    set sort(value: Array<Element>) {
      this._content["sort"] = value;
    }

    get sort(): Array<Element> {
      return this._content["sort"] as Array<Element>;
    }

    /**
     * The intended subjects of the data requirement. If this element is not
     * provided, a Patient subject is assumed.
     */
    set subject(value: CodeableConcept | Reference) {
      this._content["subject"] = value;
    }

    get subjectCodeableConcept(): CodeableConcept {
      return this._content["subject"] as CodeableConcept;
    }

    get subjectReference(): Reference {
      return this._content["subject"] as Reference;
    }

    /**
     * The type of the required data, specified as the type name of a resource.
     * For profiles, this value is set to the type of the base resource of the
     * profile.
     */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /**
     * Value filters specify additional constraints on the data for elements
     * other than code-valued or date-valued. Each value filter specifies an
     * additional constraint on the data (i.e. valueFilters are AND'ed, not
     * OR'ed).
     */
    set valueFilter(value: Array<Element>) {
      this._content["valueFilter"] = value;
    }

    get valueFilter(): Array<Element> {
      return this._content["valueFilter"] as Array<Element>;
    }
  }

  /** Distance Type: A length - a value with a unit that is a physical distance. */
  export class Distance extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Distance";
  }

  /**
   * Dosage Type: Indicates how the medication is/was taken or should be taken
   * by the patient.
   */
  export class Dosage extends BackboneType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Dosage";

    /**
     * Supplemental instructions to the patient on how to take the medication
     * (e.g. "with meals" or"take half to one hour before food") or warnings for
     * the patient about the medication (e.g. "may cause drowsiness" or "avoid
     * exposure of skin to direct sunlight or sunlamps").
     */
    set additionalInstruction(value: Array<CodeableConcept>) {
      this._content["additionalInstruction"] = value;
    }

    get additionalInstruction(): Array<CodeableConcept> {
      return this._content["additionalInstruction"] as Array<CodeableConcept>;
    }

    /**
     * Indicates whether the Medication is only taken when needed within a
     * specific dosing schedule (Boolean option).
     */
    set asNeeded(value: Boolean) {
      this._content["asNeeded"] = value;
    }

    get asNeeded(): Boolean {
      return this._content["asNeeded"] as Boolean;
    }

    /**
     * Indicates whether the Medication is only taken based on a precondition
     * for taking the Medication (CodeableConcept).
     */
    set asNeededFor(value: Array<CodeableConcept>) {
      this._content["asNeededFor"] = value;
    }

    get asNeededFor(): Array<CodeableConcept> {
      return this._content["asNeededFor"] as Array<CodeableConcept>;
    }

    /**
     * Depending on the resource,this is the amount of medication administered,
     * to be administered or typical amount to be administered.
     */
    set doseAndRate(value: Array<Element>) {
      this._content["doseAndRate"] = value;
    }

    get doseAndRate(): Array<Element> {
      return this._content["doseAndRate"] as Array<Element>;
    }

    /** Upper limit on medication per administration. */
    set maxDosePerAdministration(value: Quantity) {
      this._content["maxDosePerAdministration"] = value;
    }

    get maxDosePerAdministration(): Quantity {
      return this._content["maxDosePerAdministration"] as Quantity;
    }

    /** Upper limit on medication per lifetime of the patient. */
    set maxDosePerLifetime(value: Quantity) {
      this._content["maxDosePerLifetime"] = value;
    }

    get maxDosePerLifetime(): Quantity {
      return this._content["maxDosePerLifetime"] as Quantity;
    }

    /** Upper limit on medication per unit of time. */
    set maxDosePerPeriod(value: Array<Ratio>) {
      this._content["maxDosePerPeriod"] = value;
    }

    get maxDosePerPeriod(): Array<Ratio> {
      return this._content["maxDosePerPeriod"] as Array<Ratio>;
    }

    /** Technique for administering medication. */
    set method(value: CodeableConcept) {
      this._content["method"] = value;
    }

    get method(): CodeableConcept {
      return this._content["method"] as CodeableConcept;
    }

    /** Instructions in terms that are understood by the patient or consumer. */
    set patientInstruction(value: String) {
      this._content["patientInstruction"] = value;
    }

    get patientInstruction(): String {
      return this._content["patientInstruction"] as String;
    }

    /** How drug should enter body. */
    set route(value: CodeableConcept) {
      this._content["route"] = value;
    }

    get route(): CodeableConcept {
      return this._content["route"] as CodeableConcept;
    }

    /**
     * Indicates the order in which the dosage instructions should be applied or
     * interpreted.
     */
    set sequence(value: Integer) {
      this._content["sequence"] = value;
    }

    get sequence(): Integer {
      return this._content["sequence"] as Integer;
    }

    /** Body site to administer to. */
    set site(value: CodeableConcept) {
      this._content["site"] = value;
    }

    get site(): CodeableConcept {
      return this._content["site"] as CodeableConcept;
    }

    /** Free text dosage instructions e.g. SIG. */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /** When medication should be administered. */
    set timing(value: Timing) {
      this._content["timing"] = value;
    }

    get timing(): Timing {
      return this._content["timing"] as Timing;
    }
  }

  /** Duration Type: A length of time. */
  export class Duration extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Duration";
  }

  /**
   * ElementDefinition Type: Captures constraints on each element within the
   * resource, profile, or extension.
   */
  export class ElementDefinition extends BackboneType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ElementDefinition";

    /** Identifies additional names by which this element might also be known. */
    set alias(value: Array<String>) {
      this._content["alias"] = value;
    }

    get alias(): Array<String> {
      return this._content["alias"] as Array<String>;
    }

    /**
     * Information about the base definition of the element, provided to make it
     * unnecessary for tools to trace the deviation of the element through the
     * derived and related profiles. When the element definition is not the
     * original definition of an element - e.g. either in a constraint on
     * another type, or for elements from a super type in a snap shot - then the
     * information in provided in the element definition may be different to the
     * base definition. On the original definition of the element, it will be
     * same.
     */
    set base(value: Element) {
      this._content["base"] = value;
    }

    get base(): Element {
      return this._content["base"] as Element;
    }

    /**
     * Binds to a value set if this element is coded (code, Coding,
     * CodeableConcept, Quantity), or the data types (string, uri).
     */
    set binding(value: Element) {
      this._content["binding"] = value;
    }

    get binding(): Element {
      return this._content["binding"] as Element;
    }

    /**
     * A code that has the same meaning as the element in a particular
     * terminology.
     */
    set code(value: Array<Coding>) {
      this._content["code"] = value;
    }

    get code(): Array<Coding> {
      return this._content["code"] as Array<Coding>;
    }

    /**
     * Explanatory notes and implementation guidance about the data element,
     * including notes about how to use the data properly, exceptions to proper
     * use, etc. (Note: The text you are reading is specified in
     * ElementDefinition.comment).
     */
    set comment(value: Markdown) {
      this._content["comment"] = value;
    }

    get comment(): Markdown {
      return this._content["comment"] as Markdown;
    }

    /**
     * A reference to an invariant that may make additional statements about the
     * cardinality or value in the instance.
     */
    set condition(value: Array<Id>) {
      this._content["condition"] = value;
    }

    get condition(): Array<Id> {
      return this._content["condition"] as Array<Id>;
    }

    /**
     * Formal constraints such as co-occurrence and other constraints that can
     * be computationally evaluated within the context of the instance.
     */
    set constraint(value: Array<Element>) {
      this._content["constraint"] = value;
    }

    get constraint(): Array<Element> {
      return this._content["constraint"] as Array<Element>;
    }

    /**
     * Identifies an element defined elsewhere in the definition whose content
     * rules should be applied to the current element. ContentReferences bring
     * across all the rules that are in the ElementDefinition for the element,
     * including definitions, cardinality constraints, bindings, invariants
     * etc.
     */
    set contentReference(value: Uri) {
      this._content["contentReference"] = value;
    }

    get contentReference(): Uri {
      return this._content["contentReference"] as Uri;
    }

    /**
     * The value that should be used if there is no value stated in the instance
     * (e.g. 'if not otherwise specified, the abstract is false').
     */
    set defaultValue(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Integer64
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Availability
        | ExtendedContactDetail
        | Dosage
        | Meta,
    ) {
      this._content["defaultValue"] = value;
    }

    get defaultValueBase64Binary(): Base64Binary {
      return this._content["defaultValue"] as Base64Binary;
    }

    get defaultValueBoolean(): Boolean {
      return this._content["defaultValue"] as Boolean;
    }

    get defaultValueCanonical(): Canonical {
      return this._content["defaultValue"] as Canonical;
    }

    get defaultValueCode(): Code {
      return this._content["defaultValue"] as Code;
    }

    get defaultValueDate(): Date {
      return this._content["defaultValue"] as Date;
    }

    get defaultValueDateTime(): DateTime {
      return this._content["defaultValue"] as DateTime;
    }

    get defaultValueDecimal(): Decimal {
      return this._content["defaultValue"] as Decimal;
    }

    get defaultValueId(): Id {
      return this._content["defaultValue"] as Id;
    }

    get defaultValueInstant(): Instant {
      return this._content["defaultValue"] as Instant;
    }

    get defaultValueInteger(): Integer {
      return this._content["defaultValue"] as Integer;
    }

    get defaultValueInteger64(): Integer64 {
      return this._content["defaultValue"] as Integer64;
    }

    get defaultValueMarkdown(): Markdown {
      return this._content["defaultValue"] as Markdown;
    }

    get defaultValueOid(): Oid {
      return this._content["defaultValue"] as Oid;
    }

    get defaultValuePositiveInt(): PositiveInt {
      return this._content["defaultValue"] as PositiveInt;
    }

    get defaultValueString(): String {
      return this._content["defaultValue"] as String;
    }

    get defaultValueTime(): Time {
      return this._content["defaultValue"] as Time;
    }

    get defaultValueUnsignedInt(): UnsignedInt {
      return this._content["defaultValue"] as UnsignedInt;
    }

    get defaultValueUri(): Uri {
      return this._content["defaultValue"] as Uri;
    }

    get defaultValueUrl(): Url {
      return this._content["defaultValue"] as Url;
    }

    get defaultValueUuid(): Uuid {
      return this._content["defaultValue"] as Uuid;
    }

    get defaultValueAddress(): Address {
      return this._content["defaultValue"] as Address;
    }

    get defaultValueAge(): Age {
      return this._content["defaultValue"] as Age;
    }

    get defaultValueAnnotation(): Annotation {
      return this._content["defaultValue"] as Annotation;
    }

    get defaultValueAttachment(): Attachment {
      return this._content["defaultValue"] as Attachment;
    }

    get defaultValueCodeableConcept(): CodeableConcept {
      return this._content["defaultValue"] as CodeableConcept;
    }

    get defaultValueCodeableReference(): CodeableReference {
      return this._content["defaultValue"] as CodeableReference;
    }

    get defaultValueCoding(): Coding {
      return this._content["defaultValue"] as Coding;
    }

    get defaultValueContactPoint(): ContactPoint {
      return this._content["defaultValue"] as ContactPoint;
    }

    get defaultValueCount(): Count {
      return this._content["defaultValue"] as Count;
    }

    get defaultValueDistance(): Distance {
      return this._content["defaultValue"] as Distance;
    }

    get defaultValueDuration(): Duration {
      return this._content["defaultValue"] as Duration;
    }

    get defaultValueHumanName(): HumanName {
      return this._content["defaultValue"] as HumanName;
    }

    get defaultValueIdentifier(): Identifier {
      return this._content["defaultValue"] as Identifier;
    }

    get defaultValueMoney(): Money {
      return this._content["defaultValue"] as Money;
    }

    get defaultValuePeriod(): Period {
      return this._content["defaultValue"] as Period;
    }

    get defaultValueQuantity(): Quantity {
      return this._content["defaultValue"] as Quantity;
    }

    get defaultValueRange(): Range {
      return this._content["defaultValue"] as Range;
    }

    get defaultValueRatio(): Ratio {
      return this._content["defaultValue"] as Ratio;
    }

    get defaultValueRatioRange(): RatioRange {
      return this._content["defaultValue"] as RatioRange;
    }

    get defaultValueReference(): Reference {
      return this._content["defaultValue"] as Reference;
    }

    get defaultValueSampledData(): SampledData {
      return this._content["defaultValue"] as SampledData;
    }

    get defaultValueSignature(): Signature {
      return this._content["defaultValue"] as Signature;
    }

    get defaultValueTiming(): Timing {
      return this._content["defaultValue"] as Timing;
    }

    get defaultValueContactDetail(): ContactDetail {
      return this._content["defaultValue"] as ContactDetail;
    }

    get defaultValueDataRequirement(): DataRequirement {
      return this._content["defaultValue"] as DataRequirement;
    }

    get defaultValueExpression(): Expression {
      return this._content["defaultValue"] as Expression;
    }

    get defaultValueParameterDefinition(): ParameterDefinition {
      return this._content["defaultValue"] as ParameterDefinition;
    }

    get defaultValueRelatedArtifact(): RelatedArtifact {
      return this._content["defaultValue"] as RelatedArtifact;
    }

    get defaultValueTriggerDefinition(): TriggerDefinition {
      return this._content["defaultValue"] as TriggerDefinition;
    }

    get defaultValueUsageContext(): UsageContext {
      return this._content["defaultValue"] as UsageContext;
    }

    get defaultValueAvailability(): Availability {
      return this._content["defaultValue"] as Availability;
    }

    get defaultValueExtendedContactDetail(): ExtendedContactDetail {
      return this._content["defaultValue"] as ExtendedContactDetail;
    }

    get defaultValueDosage(): Dosage {
      return this._content["defaultValue"] as Dosage;
    }

    get defaultValueMeta(): Meta {
      return this._content["defaultValue"] as Meta;
    }

    /**
     * Provides a complete explanation of the meaning of the data element for
     * human readability. For the case of elements derived from existing
     * elements (e.g. constraints), the definition SHALL be consistent with the
     * base definition, but convey the meaning of the element in the particular
     * context of use of the resource. (Note: The text you are reading is
     * specified in ElementDefinition.definition).
     */
    set definition(value: Markdown) {
      this._content["definition"] = value;
    }

    get definition(): Markdown {
      return this._content["definition"] as Markdown;
    }

    /**
     * A sample value for this element demonstrating the type of information
     * that would typically be found in the element.
     */
    set example(value: Array<Element>) {
      this._content["example"] = value;
    }

    get example(): Array<Element> {
      return this._content["example"] as Array<Element>;
    }

    /**
     * Specifies a value that SHALL be exactly the value for this element in the
     * instance, if present. For purposes of comparison, non-significant
     * whitespace is ignored, and all values must be an exact match (case and
     * accent sensitive). Missing elements/attributes must also be missing.
     */
    set fixed(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Integer64
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Availability
        | ExtendedContactDetail
        | Dosage
        | Meta,
    ) {
      this._content["fixed"] = value;
    }

    get fixedBase64Binary(): Base64Binary {
      return this._content["fixed"] as Base64Binary;
    }

    get fixedBoolean(): Boolean {
      return this._content["fixed"] as Boolean;
    }

    get fixedCanonical(): Canonical {
      return this._content["fixed"] as Canonical;
    }

    get fixedCode(): Code {
      return this._content["fixed"] as Code;
    }

    get fixedDate(): Date {
      return this._content["fixed"] as Date;
    }

    get fixedDateTime(): DateTime {
      return this._content["fixed"] as DateTime;
    }

    get fixedDecimal(): Decimal {
      return this._content["fixed"] as Decimal;
    }

    get fixedId(): Id {
      return this._content["fixed"] as Id;
    }

    get fixedInstant(): Instant {
      return this._content["fixed"] as Instant;
    }

    get fixedInteger(): Integer {
      return this._content["fixed"] as Integer;
    }

    get fixedInteger64(): Integer64 {
      return this._content["fixed"] as Integer64;
    }

    get fixedMarkdown(): Markdown {
      return this._content["fixed"] as Markdown;
    }

    get fixedOid(): Oid {
      return this._content["fixed"] as Oid;
    }

    get fixedPositiveInt(): PositiveInt {
      return this._content["fixed"] as PositiveInt;
    }

    get fixedString(): String {
      return this._content["fixed"] as String;
    }

    get fixedTime(): Time {
      return this._content["fixed"] as Time;
    }

    get fixedUnsignedInt(): UnsignedInt {
      return this._content["fixed"] as UnsignedInt;
    }

    get fixedUri(): Uri {
      return this._content["fixed"] as Uri;
    }

    get fixedUrl(): Url {
      return this._content["fixed"] as Url;
    }

    get fixedUuid(): Uuid {
      return this._content["fixed"] as Uuid;
    }

    get fixedAddress(): Address {
      return this._content["fixed"] as Address;
    }

    get fixedAge(): Age {
      return this._content["fixed"] as Age;
    }

    get fixedAnnotation(): Annotation {
      return this._content["fixed"] as Annotation;
    }

    get fixedAttachment(): Attachment {
      return this._content["fixed"] as Attachment;
    }

    get fixedCodeableConcept(): CodeableConcept {
      return this._content["fixed"] as CodeableConcept;
    }

    get fixedCodeableReference(): CodeableReference {
      return this._content["fixed"] as CodeableReference;
    }

    get fixedCoding(): Coding {
      return this._content["fixed"] as Coding;
    }

    get fixedContactPoint(): ContactPoint {
      return this._content["fixed"] as ContactPoint;
    }

    get fixedCount(): Count {
      return this._content["fixed"] as Count;
    }

    get fixedDistance(): Distance {
      return this._content["fixed"] as Distance;
    }

    get fixedDuration(): Duration {
      return this._content["fixed"] as Duration;
    }

    get fixedHumanName(): HumanName {
      return this._content["fixed"] as HumanName;
    }

    get fixedIdentifier(): Identifier {
      return this._content["fixed"] as Identifier;
    }

    get fixedMoney(): Money {
      return this._content["fixed"] as Money;
    }

    get fixedPeriod(): Period {
      return this._content["fixed"] as Period;
    }

    get fixedQuantity(): Quantity {
      return this._content["fixed"] as Quantity;
    }

    get fixedRange(): Range {
      return this._content["fixed"] as Range;
    }

    get fixedRatio(): Ratio {
      return this._content["fixed"] as Ratio;
    }

    get fixedRatioRange(): RatioRange {
      return this._content["fixed"] as RatioRange;
    }

    get fixedReference(): Reference {
      return this._content["fixed"] as Reference;
    }

    get fixedSampledData(): SampledData {
      return this._content["fixed"] as SampledData;
    }

    get fixedSignature(): Signature {
      return this._content["fixed"] as Signature;
    }

    get fixedTiming(): Timing {
      return this._content["fixed"] as Timing;
    }

    get fixedContactDetail(): ContactDetail {
      return this._content["fixed"] as ContactDetail;
    }

    get fixedDataRequirement(): DataRequirement {
      return this._content["fixed"] as DataRequirement;
    }

    get fixedExpression(): Expression {
      return this._content["fixed"] as Expression;
    }

    get fixedParameterDefinition(): ParameterDefinition {
      return this._content["fixed"] as ParameterDefinition;
    }

    get fixedRelatedArtifact(): RelatedArtifact {
      return this._content["fixed"] as RelatedArtifact;
    }

    get fixedTriggerDefinition(): TriggerDefinition {
      return this._content["fixed"] as TriggerDefinition;
    }

    get fixedUsageContext(): UsageContext {
      return this._content["fixed"] as UsageContext;
    }

    get fixedAvailability(): Availability {
      return this._content["fixed"] as Availability;
    }

    get fixedExtendedContactDetail(): ExtendedContactDetail {
      return this._content["fixed"] as ExtendedContactDetail;
    }

    get fixedDosage(): Dosage {
      return this._content["fixed"] as Dosage;
    }

    get fixedMeta(): Meta {
      return this._content["fixed"] as Meta;
    }

    /**
     * If true, the value of this element affects the interpretation of the
     * element or resource that contains it, and the value of the element cannot
     * be ignored. Typically, this is used for status, negation and
     * qualification codes. The effect of this is that the element cannot be
     * ignored by systems: they SHALL either recognize the element and process
     * it, and/or a pre-determination has been made that it is not relevant to
     * their particular system. When used on the root element in an extension
     * definition, this indicates whether or not the extension is a modifier
     * extension.
     */
    set isModifier(value: Boolean) {
      this._content["isModifier"] = value;
    }

    get isModifier(): Boolean {
      return this._content["isModifier"] as Boolean;
    }

    /**
     * Explains how that element affects the interpretation of the resource or
     * element that contains it.
     */
    set isModifierReason(value: String) {
      this._content["isModifierReason"] = value;
    }

    get isModifierReason(): String {
      return this._content["isModifierReason"] as String;
    }

    /**
     * Whether the element should be included if a client requests a search with
     * the parameter _summary=true.
     */
    set isSummary(value: Boolean) {
      this._content["isSummary"] = value;
    }

    get isSummary(): Boolean {
      return this._content["isSummary"] as Boolean;
    }

    /**
     * A single preferred label which is the text to display beside the element
     * indicating its meaning or to use to prompt for the element in a user
     * display or form.
     */
    set label(value: String) {
      this._content["label"] = value;
    }

    get label(): String {
      return this._content["label"] as String;
    }

    /**
     * Identifies a concept from an external specification that roughly
     * corresponds to this element.
     */
    set mapping(value: Array<Element>) {
      this._content["mapping"] = value;
    }

    get mapping(): Array<Element> {
      return this._content["mapping"] as Array<Element>;
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * instance.
     */
    set max(value: String) {
      this._content["max"] = value;
    }

    get max(): String {
      return this._content["max"] as String;
    }

    /**
     * Indicates the maximum length in characters that is permitted to be
     * present in conformant instances and which is expected to be supported by
     * conformant consumers that support the element. `maxLength` SHOULD only be
     * used on primitive data types that have a string representation (see
     * [http://hl7.org/fhir/StructureDefinition/structuredefinition-type-characteristics](http://hl7.org/fhir/extensions/StructureDefinition-structuredefinition-type-characteristics.html)).
     */
    set maxLength(value: Integer) {
      this._content["maxLength"] = value;
    }

    get maxLength(): Integer {
      return this._content["maxLength"] as Integer;
    }

    /**
     * The maximum allowed value for the element. The value is inclusive. This
     * is allowed for the types date, dateTime, instant, time, decimal, integer,
     * and Quantity.
     */
    set maxValue(
      value:
        | Date
        | DateTime
        | Instant
        | Time
        | Decimal
        | Integer
        | Integer64
        | PositiveInt
        | UnsignedInt
        | Quantity,
    ) {
      this._content["maxValue"] = value;
    }

    get maxValueDate(): Date {
      return this._content["maxValue"] as Date;
    }

    get maxValueDateTime(): DateTime {
      return this._content["maxValue"] as DateTime;
    }

    get maxValueInstant(): Instant {
      return this._content["maxValue"] as Instant;
    }

    get maxValueTime(): Time {
      return this._content["maxValue"] as Time;
    }

    get maxValueDecimal(): Decimal {
      return this._content["maxValue"] as Decimal;
    }

    get maxValueInteger(): Integer {
      return this._content["maxValue"] as Integer;
    }

    get maxValueInteger64(): Integer64 {
      return this._content["maxValue"] as Integer64;
    }

    get maxValuePositiveInt(): PositiveInt {
      return this._content["maxValue"] as PositiveInt;
    }

    get maxValueUnsignedInt(): UnsignedInt {
      return this._content["maxValue"] as UnsignedInt;
    }

    get maxValueQuantity(): Quantity {
      return this._content["maxValue"] as Quantity;
    }

    /**
     * The Implicit meaning that is to be understood when this element is
     * missing (e.g. 'when this element is missing, the period is ongoing').
     */
    set meaningWhenMissing(value: Markdown) {
      this._content["meaningWhenMissing"] = value;
    }

    get meaningWhenMissing(): Markdown {
      return this._content["meaningWhenMissing"] as Markdown;
    }

    /** The minimum number of times this element SHALL appear in the instance. */
    set min(value: UnsignedInt) {
      this._content["min"] = value;
    }

    get min(): UnsignedInt {
      return this._content["min"] as UnsignedInt;
    }

    /**
     * The minimum allowed value for the element. The value is inclusive. This
     * is allowed for the types date, dateTime, instant, time, decimal, integer,
     * and Quantity.
     */
    set minValue(
      value:
        | Date
        | DateTime
        | Instant
        | Time
        | Decimal
        | Integer
        | Integer64
        | PositiveInt
        | UnsignedInt
        | Quantity,
    ) {
      this._content["minValue"] = value;
    }

    get minValueDate(): Date {
      return this._content["minValue"] as Date;
    }

    get minValueDateTime(): DateTime {
      return this._content["minValue"] as DateTime;
    }

    get minValueInstant(): Instant {
      return this._content["minValue"] as Instant;
    }

    get minValueTime(): Time {
      return this._content["minValue"] as Time;
    }

    get minValueDecimal(): Decimal {
      return this._content["minValue"] as Decimal;
    }

    get minValueInteger(): Integer {
      return this._content["minValue"] as Integer;
    }

    get minValueInteger64(): Integer64 {
      return this._content["minValue"] as Integer64;
    }

    get minValuePositiveInt(): PositiveInt {
      return this._content["minValue"] as PositiveInt;
    }

    get minValueUnsignedInt(): UnsignedInt {
      return this._content["minValue"] as UnsignedInt;
    }

    get minValueQuantity(): Quantity {
      return this._content["minValue"] as Quantity;
    }

    /**
     * Specifies for a primitive data type that the value of the data type
     * cannot be replaced by an extension.
     */
    set mustHaveValue(value: Boolean) {
      this._content["mustHaveValue"] = value;
    }

    get mustHaveValue(): Boolean {
      return this._content["mustHaveValue"] as Boolean;
    }

    /**
     * If true, implementations that produce or consume resources SHALL provide
     * "support" for the element in some meaningful way. Note that this is being
     * phased out and replaced by obligations (see below). If false, the element
     * may be ignored and not supported. If false, whether to populate or use
     * the data element in any way is at the discretion of the implementation.
     */
    set mustSupport(value: Boolean) {
      this._content["mustSupport"] = value;
    }

    get mustSupport(): Boolean {
      return this._content["mustSupport"] as Boolean;
    }

    /**
     * If present, indicates that the order of the repeating element has meaning
     * and describes what that meaning is. If absent, it means that the order of
     * the element has no meaning.
     */
    set orderMeaning(value: String) {
      this._content["orderMeaning"] = value;
    }

    get orderMeaning(): String {
      return this._content["orderMeaning"] as String;
    }

    /**
     * The path identifies the element and is expressed as a "."-separated list
     * of ancestor elements, beginning with the name of the resource or
     * extension.
     */
    set path(value: String) {
      this._content["path"] = value;
    }

    get path(): String {
      return this._content["path"] as String;
    }

    /**
     * Specifies a value that each occurrence of the element in the instance
     * SHALL follow - that is, any value in the pattern must be found in the
     * instance, if the element has a value. Other additional values may be
     * found too. This is effectively constraint by example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the value
     * provided in the pattern[x] must match the instance value exactly.
     *
     * When an element within a pattern[x] is used to constrain an array, it
     * means that each element provided in the pattern[x] must (recursively)
     * match at least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that each
     * property in the pattern must be present in the complex object, and its
     * value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value
     *
     * If a pattern[x] is declared on a repeating element, the pattern applies
     * to all repetitions. If the desire is for a pattern to apply to only one
     * element or a subset of elements, slicing must be used. See [Examples of
     * Patterns](elementdefinition-examples.html#pattern-examples) for examples
     * of pattern usage and the effect it will have.
     */
    set pattern(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Integer64
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Availability
        | ExtendedContactDetail
        | Dosage
        | Meta,
    ) {
      this._content["pattern"] = value;
    }

    get patternBase64Binary(): Base64Binary {
      return this._content["pattern"] as Base64Binary;
    }

    get patternBoolean(): Boolean {
      return this._content["pattern"] as Boolean;
    }

    get patternCanonical(): Canonical {
      return this._content["pattern"] as Canonical;
    }

    get patternCode(): Code {
      return this._content["pattern"] as Code;
    }

    get patternDate(): Date {
      return this._content["pattern"] as Date;
    }

    get patternDateTime(): DateTime {
      return this._content["pattern"] as DateTime;
    }

    get patternDecimal(): Decimal {
      return this._content["pattern"] as Decimal;
    }

    get patternId(): Id {
      return this._content["pattern"] as Id;
    }

    get patternInstant(): Instant {
      return this._content["pattern"] as Instant;
    }

    get patternInteger(): Integer {
      return this._content["pattern"] as Integer;
    }

    get patternInteger64(): Integer64 {
      return this._content["pattern"] as Integer64;
    }

    get patternMarkdown(): Markdown {
      return this._content["pattern"] as Markdown;
    }

    get patternOid(): Oid {
      return this._content["pattern"] as Oid;
    }

    get patternPositiveInt(): PositiveInt {
      return this._content["pattern"] as PositiveInt;
    }

    get patternString(): String {
      return this._content["pattern"] as String;
    }

    get patternTime(): Time {
      return this._content["pattern"] as Time;
    }

    get patternUnsignedInt(): UnsignedInt {
      return this._content["pattern"] as UnsignedInt;
    }

    get patternUri(): Uri {
      return this._content["pattern"] as Uri;
    }

    get patternUrl(): Url {
      return this._content["pattern"] as Url;
    }

    get patternUuid(): Uuid {
      return this._content["pattern"] as Uuid;
    }

    get patternAddress(): Address {
      return this._content["pattern"] as Address;
    }

    get patternAge(): Age {
      return this._content["pattern"] as Age;
    }

    get patternAnnotation(): Annotation {
      return this._content["pattern"] as Annotation;
    }

    get patternAttachment(): Attachment {
      return this._content["pattern"] as Attachment;
    }

    get patternCodeableConcept(): CodeableConcept {
      return this._content["pattern"] as CodeableConcept;
    }

    get patternCodeableReference(): CodeableReference {
      return this._content["pattern"] as CodeableReference;
    }

    get patternCoding(): Coding {
      return this._content["pattern"] as Coding;
    }

    get patternContactPoint(): ContactPoint {
      return this._content["pattern"] as ContactPoint;
    }

    get patternCount(): Count {
      return this._content["pattern"] as Count;
    }

    get patternDistance(): Distance {
      return this._content["pattern"] as Distance;
    }

    get patternDuration(): Duration {
      return this._content["pattern"] as Duration;
    }

    get patternHumanName(): HumanName {
      return this._content["pattern"] as HumanName;
    }

    get patternIdentifier(): Identifier {
      return this._content["pattern"] as Identifier;
    }

    get patternMoney(): Money {
      return this._content["pattern"] as Money;
    }

    get patternPeriod(): Period {
      return this._content["pattern"] as Period;
    }

    get patternQuantity(): Quantity {
      return this._content["pattern"] as Quantity;
    }

    get patternRange(): Range {
      return this._content["pattern"] as Range;
    }

    get patternRatio(): Ratio {
      return this._content["pattern"] as Ratio;
    }

    get patternRatioRange(): RatioRange {
      return this._content["pattern"] as RatioRange;
    }

    get patternReference(): Reference {
      return this._content["pattern"] as Reference;
    }

    get patternSampledData(): SampledData {
      return this._content["pattern"] as SampledData;
    }

    get patternSignature(): Signature {
      return this._content["pattern"] as Signature;
    }

    get patternTiming(): Timing {
      return this._content["pattern"] as Timing;
    }

    get patternContactDetail(): ContactDetail {
      return this._content["pattern"] as ContactDetail;
    }

    get patternDataRequirement(): DataRequirement {
      return this._content["pattern"] as DataRequirement;
    }

    get patternExpression(): Expression {
      return this._content["pattern"] as Expression;
    }

    get patternParameterDefinition(): ParameterDefinition {
      return this._content["pattern"] as ParameterDefinition;
    }

    get patternRelatedArtifact(): RelatedArtifact {
      return this._content["pattern"] as RelatedArtifact;
    }

    get patternTriggerDefinition(): TriggerDefinition {
      return this._content["pattern"] as TriggerDefinition;
    }

    get patternUsageContext(): UsageContext {
      return this._content["pattern"] as UsageContext;
    }

    get patternAvailability(): Availability {
      return this._content["pattern"] as Availability;
    }

    get patternExtendedContactDetail(): ExtendedContactDetail {
      return this._content["pattern"] as ExtendedContactDetail;
    }

    get patternDosage(): Dosage {
      return this._content["pattern"] as Dosage;
    }

    get patternMeta(): Meta {
      return this._content["pattern"] as Meta;
    }

    /**
     * Codes that define how this element is represented in instances, when the
     * deviation varies from the normal case. No extensions are allowed on
     * elements with a representation of 'xmlAttr', no matter what FHIR
     * serialization format is used.
     */
    set representation(value: Array<Code>) {
      this._content["representation"] = value;
    }

    get representation(): Array<Code> {
      return this._content["representation"] as Array<Code>;
    }

    /**
     * This element is for traceability of why the element was created and why
     * the constraints exist as they do. This may be used to point to source
     * materials or specifications that drove the structure of this element.
     */
    set requirements(value: Markdown) {
      this._content["requirements"] = value;
    }

    get requirements(): Markdown {
      return this._content["requirements"] as Markdown;
    }

    /**
     * A concise description of what this element means (e.g. for use in
     * autogenerated summaries).
     */
    set short(value: String) {
      this._content["short"] = value;
    }

    get short(): String {
      return this._content["short"] as String;
    }

    /**
     * If true, indicates that this slice definition is constraining a slice
     * definition with the same name in an inherited profile. If false, the
     * slice is not overriding any slice in an inherited profile. If missing,
     * the slice might or might not be overriding a slice in an inherited
     * profile, depending on the sliceName.
     */
    set sliceIsConstraining(value: Boolean) {
      this._content["sliceIsConstraining"] = value;
    }

    get sliceIsConstraining(): Boolean {
      return this._content["sliceIsConstraining"] as Boolean;
    }

    /**
     * The name of this element definition slice, when slicing is working. The
     * name must be a token with no dots or spaces. This is a unique name
     * referring to a specific set of constraints applied to this element, used
     * to provide a name to different slices of the same element.
     */
    set sliceName(value: String) {
      this._content["sliceName"] = value;
    }

    get sliceName(): String {
      return this._content["sliceName"] as String;
    }

    /**
     * Indicates that the element is sliced into a set of alternative
     * definitions (i.e. in a structure definition, there are multiple different
     * constraints on a single element in the base resource). Slicing can be
     * used in any resource that has cardinality ..* on the base resource, or
     * any resource with a choice of types. The set of slices is any elements
     * that come after this in the element sequence that have the same path,
     * until a shorter path occurs (the shorter path terminates the set).
     */
    set slicing(value: Element) {
      this._content["slicing"] = value;
    }

    get slicing(): Element {
      return this._content["slicing"] as Element;
    }

    /**
     * The data type or resource that the value of this element is permitted to
     * be.
     */
    set type(value: Array<Element>) {
      this._content["type"] = value;
    }

    get type(): Array<Element> {
      return this._content["type"] as Array<Element>;
    }

    /**
     * Specifies a list of extensions that can appear in place of a primitive
     * value.
     */
    set valueAlternatives(value: Array<Canonical>) {
      this._content["valueAlternatives"] = value;
    }

    get valueAlternatives(): Array<Canonical> {
      return this._content["valueAlternatives"] as Array<Canonical>;
    }
  }

  /**
   * Expression Type: A expression that is evaluated in a specified context and
   * returns a value. The context of use of the expression must specify the
   * context in which the expression is evaluated, and how the result of the
   * expression is used.
   */
  export class Expression extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Expression";

    /**
     * A brief, natural language description of the condition that effectively
     * communicates the intended semantics.
     */
    set description(value: String) {
      this._content["description"] = value;
    }

    get description(): String {
      return this._content["description"] as String;
    }

    /** An expression in the specified language that returns a value. */
    set expression(value: String) {
      this._content["expression"] = value;
    }

    get expression(): String {
      return this._content["expression"] as String;
    }

    /** The media type of the language for the expression. */
    set language(value: Code) {
      this._content["language"] = value;
    }

    get language(): Code {
      return this._content["language"] as Code;
    }

    /**
     * A short name assigned to the expression to allow for multiple reuse of
     * the expression in the context where it is defined.
     */
    set name(value: Code) {
      this._content["name"] = value;
    }

    get name(): Code {
      return this._content["name"] as Code;
    }

    /** A URI that defines where the expression is found. */
    set reference(value: Uri) {
      this._content["reference"] = value;
    }

    get reference(): Uri {
      return this._content["reference"] as Uri;
    }
  }

  /**
   * ExtendedContactDetail Type: Specifies contact information for a specific
   * purpose over a period of time, might be handled/monitored by a specific
   * named person or organization.
   */
  export class ExtendedContactDetail extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ExtendedContactDetail";

    /** Address for the contact. */
    set address(value: Address) {
      this._content["address"] = value;
    }

    get address(): Address {
      return this._content["address"] as Address;
    }

    /**
     * The name of an individual to contact, some types of contact detail are
     * usually blank.
     */
    set name(value: Array<HumanName>) {
      this._content["name"] = value;
    }

    get name(): Array<HumanName> {
      return this._content["name"] as Array<HumanName>;
    }

    /**
     * This contact detail is handled/monitored by a specific organization. If
     * the name is provided in the contact, then it is referring to the named
     * individual within this organization.
     */
    set organization(value: Reference) {
      this._content["organization"] = value;
    }

    get organization(): Reference {
      return this._content["organization"] as Reference;
    }

    /** Period that this contact was valid for usage. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /** The purpose/type of contact. */
    set purpose(value: CodeableConcept) {
      this._content["purpose"] = value;
    }

    get purpose(): CodeableConcept {
      return this._content["purpose"] as CodeableConcept;
    }

    /** The contact details application for the purpose defined. */
    set telecom(value: Array<ContactPoint>) {
      this._content["telecom"] = value;
    }

    get telecom(): Array<ContactPoint> {
      return this._content["telecom"] as Array<ContactPoint>;
    }
  }

  /** Extension Type: Optional Extension Element - found in all resources. */
  export class Extension extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Extension";

    /**
     * Source of the definition for the extension code - a logical name or a
     * URL.
     */
    set url(value: string) {
      this._content["url"] = value;
    }

    get url(): string {
      return this._content["url"] as string;
    }

    /**
     * Value of extension - must be one of a constrained set of the data types
     * (see [Extensibility](extensibility.html) for a list).
     */
    set value(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Integer64
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Availability
        | ExtendedContactDetail
        | Dosage
        | Meta,
    ) {
      this._content["value"] = value;
    }

    get valueBase64Binary(): Base64Binary {
      return this._content["value"] as Base64Binary;
    }

    get valueBoolean(): Boolean {
      return this._content["value"] as Boolean;
    }

    get valueCanonical(): Canonical {
      return this._content["value"] as Canonical;
    }

    get valueCode(): Code {
      return this._content["value"] as Code;
    }

    get valueDate(): Date {
      return this._content["value"] as Date;
    }

    get valueDateTime(): DateTime {
      return this._content["value"] as DateTime;
    }

    get valueDecimal(): Decimal {
      return this._content["value"] as Decimal;
    }

    get valueId(): Id {
      return this._content["value"] as Id;
    }

    get valueInstant(): Instant {
      return this._content["value"] as Instant;
    }

    get valueInteger(): Integer {
      return this._content["value"] as Integer;
    }

    get valueInteger64(): Integer64 {
      return this._content["value"] as Integer64;
    }

    get valueMarkdown(): Markdown {
      return this._content["value"] as Markdown;
    }

    get valueOid(): Oid {
      return this._content["value"] as Oid;
    }

    get valuePositiveInt(): PositiveInt {
      return this._content["value"] as PositiveInt;
    }

    get valueString(): String {
      return this._content["value"] as String;
    }

    get valueTime(): Time {
      return this._content["value"] as Time;
    }

    get valueUnsignedInt(): UnsignedInt {
      return this._content["value"] as UnsignedInt;
    }

    get valueUri(): Uri {
      return this._content["value"] as Uri;
    }

    get valueUrl(): Url {
      return this._content["value"] as Url;
    }

    get valueUuid(): Uuid {
      return this._content["value"] as Uuid;
    }

    get valueAddress(): Address {
      return this._content["value"] as Address;
    }

    get valueAge(): Age {
      return this._content["value"] as Age;
    }

    get valueAnnotation(): Annotation {
      return this._content["value"] as Annotation;
    }

    get valueAttachment(): Attachment {
      return this._content["value"] as Attachment;
    }

    get valueCodeableConcept(): CodeableConcept {
      return this._content["value"] as CodeableConcept;
    }

    get valueCodeableReference(): CodeableReference {
      return this._content["value"] as CodeableReference;
    }

    get valueCoding(): Coding {
      return this._content["value"] as Coding;
    }

    get valueContactPoint(): ContactPoint {
      return this._content["value"] as ContactPoint;
    }

    get valueCount(): Count {
      return this._content["value"] as Count;
    }

    get valueDistance(): Distance {
      return this._content["value"] as Distance;
    }

    get valueDuration(): Duration {
      return this._content["value"] as Duration;
    }

    get valueHumanName(): HumanName {
      return this._content["value"] as HumanName;
    }

    get valueIdentifier(): Identifier {
      return this._content["value"] as Identifier;
    }

    get valueMoney(): Money {
      return this._content["value"] as Money;
    }

    get valuePeriod(): Period {
      return this._content["value"] as Period;
    }

    get valueQuantity(): Quantity {
      return this._content["value"] as Quantity;
    }

    get valueRange(): Range {
      return this._content["value"] as Range;
    }

    get valueRatio(): Ratio {
      return this._content["value"] as Ratio;
    }

    get valueRatioRange(): RatioRange {
      return this._content["value"] as RatioRange;
    }

    get valueReference(): Reference {
      return this._content["value"] as Reference;
    }

    get valueSampledData(): SampledData {
      return this._content["value"] as SampledData;
    }

    get valueSignature(): Signature {
      return this._content["value"] as Signature;
    }

    get valueTiming(): Timing {
      return this._content["value"] as Timing;
    }

    get valueContactDetail(): ContactDetail {
      return this._content["value"] as ContactDetail;
    }

    get valueDataRequirement(): DataRequirement {
      return this._content["value"] as DataRequirement;
    }

    get valueExpression(): Expression {
      return this._content["value"] as Expression;
    }

    get valueParameterDefinition(): ParameterDefinition {
      return this._content["value"] as ParameterDefinition;
    }

    get valueRelatedArtifact(): RelatedArtifact {
      return this._content["value"] as RelatedArtifact;
    }

    get valueTriggerDefinition(): TriggerDefinition {
      return this._content["value"] as TriggerDefinition;
    }

    get valueUsageContext(): UsageContext {
      return this._content["value"] as UsageContext;
    }

    get valueAvailability(): Availability {
      return this._content["value"] as Availability;
    }

    get valueExtendedContactDetail(): ExtendedContactDetail {
      return this._content["value"] as ExtendedContactDetail;
    }

    get valueDosage(): Dosage {
      return this._content["value"] as Dosage;
    }

    get valueMeta(): Meta {
      return this._content["value"] as Meta;
    }
  }

  /**
   * HumanName Type: A name, normally of a human, that can be used for other
   * living entities (e.g. animals but not organizations) that have been
   * assigned names by a human and may need the use of name parts or the need
   * for usage information.
   */
  export class HumanName extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/HumanName";

    /**
     * The part of a name that links to the genealogy. In some cultures (e.g.
     * Eritrea) the family name of a son is the first name of his father.
     */
    set family(value: String) {
      this._content["family"] = value;
    }

    get family(): String {
      return this._content["family"] as String;
    }

    /** Given name. */
    set given(value: Array<String>) {
      this._content["given"] = value;
    }

    get given(): Array<String> {
      return this._content["given"] as Array<String>;
    }

    /**
     * Indicates the period of time when this name was valid for the named
     * person.
     */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Part of the name that is acquired as a title due to academic, legal,
     * employment or nobility status, etc. and that appears at the start of the
     * name.
     */
    set prefix(value: Array<String>) {
      this._content["prefix"] = value;
    }

    get prefix(): Array<String> {
      return this._content["prefix"] as Array<String>;
    }

    /**
     * Part of the name that is acquired as a title due to academic, legal,
     * employment or nobility status, etc. and that appears at the end of the
     * name.
     */
    set suffix(value: Array<String>) {
      this._content["suffix"] = value;
    }

    get suffix(): Array<String> {
      return this._content["suffix"] as Array<String>;
    }

    /**
     * Specifies the entire name as it should be displayed e.g. on an
     * application UI. This may be provided instead of or as well as the
     * specific parts.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /** Identifies the purpose for this name. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Identifier Type: An identifier - identifies some entity uniquely and
   * unambiguously. Typically this is used for business identifiers.
   */
  export class Identifier extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Identifier";

    /** Organization that issued/manages the identifier. */
    set assigner(value: Reference) {
      this._content["assigner"] = value;
    }

    get assigner(): Reference {
      return this._content["assigner"] as Reference;
    }

    /** Time period during which identifier is/was valid for use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Establishes the namespace for the value - that is, an absolute URL that
     * describes a set values that are unique.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /**
     * A coded type for the identifier that can be used to determine which
     * identifier to use for a specific purpose.
     */
    set type(value: CodeableConcept) {
      this._content["type"] = value;
    }

    get type(): CodeableConcept {
      return this._content["type"] as CodeableConcept;
    }

    /** The purpose of this identifier. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }

    /**
     * The portion of the identifier typically relevant to the user and which is
     * unique within the context of the system.
     */
    set value(value: String) {
      this._content["value"] = value;
    }

    get value(): String {
      return this._content["value"] as String;
    }
  }

  /**
   * MarketingStatus Type: The marketing status describes the date when a
   * medicinal product is actually put on the market or the date as of which it
   * is no longer available.
   */
  export class MarketingStatus extends BackboneType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MarketingStatus";

    /**
     * The country in which the marketing authorization has been granted shall
     * be specified It should be specified using the ISO 3166  1 alpha-2 code
     * elements.
     */
    set country(value: CodeableConcept) {
      this._content["country"] = value;
    }

    get country(): CodeableConcept {
      return this._content["country"] as CodeableConcept;
    }

    /**
     * The date when the Medicinal Product is placed on the market by the
     * Marketing Authorization Holder (or where applicable, the
     * manufacturer/distributor) in a country and/or jurisdiction shall be
     * provided A complete date consisting of day, month and year shall be
     * specified using the ISO 8601 date format NOTE Placed on the market
     * refers to the release of the Medicinal Product into the distribution
     * chain.
     */
    set dateRange(value: Period) {
      this._content["dateRange"] = value;
    }

    get dateRange(): Period {
      return this._content["dateRange"] as Period;
    }

    /**
     * Where a Medicines Regulatory Agency has granted a marketing authorization
     * for which specific provisions within a jurisdiction apply, the
     * jurisdiction can be specified using an appropriate controlled terminology
     * The controlled term and the controlled term identifier shall be
     * specified.
     */
    set jurisdiction(value: CodeableConcept) {
      this._content["jurisdiction"] = value;
    }

    get jurisdiction(): CodeableConcept {
      return this._content["jurisdiction"] as CodeableConcept;
    }

    /**
     * The date when the Medicinal Product is placed on the market by the
     * Marketing Authorization Holder (or where applicable, the
     * manufacturer/distributor) in a country and/or jurisdiction shall be
     * provided A complete date consisting of day, month and year shall be
     * specified using the ISO 8601 date format NOTE Placed on the market
     * refers to the release of the Medicinal Product into the distribution
     * chain.
     */
    set restoreDate(value: DateTime) {
      this._content["restoreDate"] = value;
    }

    get restoreDate(): DateTime {
      return this._content["restoreDate"] as DateTime;
    }

    /**
     * This attribute provides information on the status of the marketing of the
     * medicinal product See ISO/TS 20443 for more information and examples.
     */
    set status(value: CodeableConcept) {
      this._content["status"] = value;
    }

    get status(): CodeableConcept {
      return this._content["status"] as CodeableConcept;
    }
  }

  /**
   * Meta Type: The metadata about a resource. This is content in the resource
   * that is maintained by the infrastructure. Changes to the content might not
   * always be associated with version changes to the resource.
   */
  export class Meta extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Meta";

    /** When the resource last changed - e.g. when the version changed. */
    set lastUpdated(value: Instant) {
      this._content["lastUpdated"] = value;
    }

    get lastUpdated(): Instant {
      return this._content["lastUpdated"] as Instant;
    }

    /**
     * A list of profiles (references to
     * [StructureDefinition](structuredefinition.html#) resources) that this
     * resource claims to conform to. The URL is a reference to
     * [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
     */
    set profile(value: Array<Canonical>) {
      this._content["profile"] = value;
    }

    get profile(): Array<Canonical> {
      return this._content["profile"] as Array<Canonical>;
    }

    /**
     * Security labels applied to this resource. These tags connect specific
     * resources to the overall security policy and infrastructure.
     */
    set security(value: Array<Coding>) {
      this._content["security"] = value;
    }

    get security(): Array<Coding> {
      return this._content["security"] as Array<Coding>;
    }

    /**
     * A uri that identifies the source system of the resource. This provides a
     * minimal amount of [Provenance](provenance.html#) information that can be
     * used to track or differentiate the source of information in the resource.
     * The source may identify another FHIR server, document, message, database,
     * etc.
     */
    set source(value: Uri) {
      this._content["source"] = value;
    }

    get source(): Uri {
      return this._content["source"] as Uri;
    }

    /**
     * Tags applied to this resource. Tags are intended to be used to identify
     * and relate resources to process and workflow, and applications are not
     * required to consider the tags when interpreting the meaning of a
     * resource.
     */
    set tag(value: Array<Coding>) {
      this._content["tag"] = value;
    }

    get tag(): Array<Coding> {
      return this._content["tag"] as Array<Coding>;
    }

    /**
     * The version specific identifier, as it appears in the version portion of
     * the URL. This value changes when the resource is created, updated, or
     * deleted.
     */
    set versionId(value: Id) {
      this._content["versionId"] = value;
    }

    get versionId(): Id {
      return this._content["versionId"] as Id;
    }
  }

  /** MonetaryComponent Type: Availability data for an {item}. */
  export class MonetaryComponent extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MonetaryComponent";

    /** Explicit value amount to be used. */
    set amount(value: Money) {
      this._content["amount"] = value;
    }

    get amount(): Money {
      return this._content["amount"] as Money;
    }

    /**
     * Codes may be used to differentiate between kinds of taxes, surcharges,
     * discounts etc.
     */
    set code(value: CodeableConcept) {
      this._content["code"] = value;
    }

    get code(): CodeableConcept {
      return this._content["code"] as CodeableConcept;
    }

    /** Factor used for calculating this component. */
    set factor(value: Decimal) {
      this._content["factor"] = value;
    }

    get factor(): Decimal {
      return this._content["factor"] as Decimal;
    }

    /** Base | surcharge | deduction | discount | tax | informational. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /** Money Type: An amount of economic utility in some recognized currency. */
  export class Money extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Money";

    /** ISO 4217 Currency Code. */
    set currency(value: Code) {
      this._content["currency"] = value;
    }

    get currency(): Code {
      return this._content["currency"] as Code;
    }

    /** Numerical value (with implicit precision). */
    set value(value: Decimal) {
      this._content["value"] = value;
    }

    get value(): Decimal {
      return this._content["value"] as Decimal;
    }
  }

  /**
   * Narrative Type: A human-readable summary of the resource conveying the
   * essential clinical and business information for the resource.
   */
  export class Narrative extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Narrative";

    /** The actual narrative content, a stripped down version of XHTML. */
    set div(value: Xhtml) {
      this._content["div"] = value;
    }

    get div(): Xhtml {
      return this._content["div"] as Xhtml;
    }

    /**
     * The status of the narrative - whether it's entirely generated (from just
     * the defined data or the extensions too), or whether a human authored it
     * and it may contain additional data.
     */
    set status(value: Code) {
      this._content["status"] = value;
    }

    get status(): Code {
      return this._content["status"] as Code;
    }
  }

  /**
   * ParameterDefinition Type: The parameters to the module. This collection
   * specifies both the input and output parameters. Input parameters are
   * provided by the caller as part of the $evaluate operation. Output
   * parameters are included in the GuidanceResponse.
   */
  export class ParameterDefinition extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ParameterDefinition";

    /**
     * A brief discussion of what the parameter is for and how it is used by the
     * module.
     */
    set documentation(value: String) {
      this._content["documentation"] = value;
    }

    get documentation(): String {
      return this._content["documentation"] as String;
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * request or response.
     */
    set max(value: String) {
      this._content["max"] = value;
    }

    get max(): String {
      return this._content["max"] as String;
    }

    /**
     * The minimum number of times this parameter SHALL appear in the request or
     * response.
     */
    set min(value: Integer) {
      this._content["min"] = value;
    }

    get min(): Integer {
      return this._content["min"] as Integer;
    }

    /**
     * The name of the parameter used to allow access to the value of the
     * parameter in evaluation contexts.
     */
    set name(value: Code) {
      this._content["name"] = value;
    }

    get name(): Code {
      return this._content["name"] as Code;
    }

    /**
     * If specified, this indicates a profile that the input data must conform
     * to, or that the output data will conform to.
     */
    set profile(value: Canonical) {
      this._content["profile"] = value;
    }

    get profile(): Canonical {
      return this._content["profile"] as Canonical;
    }

    /** The type of the parameter. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /** Whether the parameter is input or output for the module. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Period Type: A time period defined by a start and end date and optionally
   * time.
   */
  export class Period extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Period";

    /**
     * The end of the period. If the end of the period is missing, it means no
     * end was known or planned at the time the instance was created. The start
     * may be in the past, and the end date in the future, which means that
     * period is expected/planned to end at that time.
     */
    set end(value: DateTime) {
      this._content["end"] = value;
    }

    get end(): DateTime {
      return this._content["end"] as DateTime;
    }

    /** The start of the period. The boundary is inclusive. */
    set start(value: DateTime) {
      this._content["start"] = value;
    }

    get start(): DateTime {
      return this._content["start"] as DateTime;
    }
  }

  /**
   * ProductShelfLife Type: The shelf-life and storage information for a
   * medicinal product item or container can be described using this class.
   */
  export class ProductShelfLife extends BackboneType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ProductShelfLife";

    /**
     * The shelf life time period can be specified using a numerical value for
     * the period of time and its unit of time measurement The unit of
     * measurement shall be specified in accordance with ISO 11240 and the
     * resulting terminology The symbol and the symbol identifier shall be
     * used.
     */
    set period(value: Duration | String) {
      this._content["period"] = value;
    }

    get periodDuration(): Duration {
      return this._content["period"] as Duration;
    }

    get periodString(): String {
      return this._content["period"] as String;
    }

    /**
     * Special precautions for storage, if any, can be specified using an
     * appropriate controlled vocabulary The controlled term and the controlled
     * term identifier shall be specified.
     */
    set specialPrecautionsForStorage(value: Array<CodeableConcept>) {
      this._content["specialPrecautionsForStorage"] = value;
    }

    get specialPrecautionsForStorage(): Array<CodeableConcept> {
      return this._content[
        "specialPrecautionsForStorage"
      ] as Array<CodeableConcept>;
    }

    /**
     * This describes the shelf life, taking into account various scenarios such
     * as shelf life of the packaged Medicinal Product itself, shelf life after
     * transformation where necessary and shelf life after the first opening of
     * a bottle, etc. The shelf life type shall be specified using an
     * appropriate controlled vocabulary The controlled term and the controlled
     * term identifier shall be specified.
     */
    set type(value: CodeableConcept) {
      this._content["type"] = value;
    }

    get type(): CodeableConcept {
      return this._content["type"] as CodeableConcept;
    }
  }

  /** Range Type: A set of ordered Quantities defined by a low and high limit. */
  export class Range extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Range";

    /** The high limit. The boundary is inclusive. */
    set high(value: Quantity) {
      this._content["high"] = value;
    }

    get high(): Quantity {
      return this._content["high"] as Quantity;
    }

    /** The low limit. The boundary is inclusive. */
    set low(value: Quantity) {
      this._content["low"] = value;
    }

    get low(): Quantity {
      return this._content["low"] as Quantity;
    }
  }

  /**
   * Ratio Type: A relationship of two Quantity values - expressed as a
   * numerator and a denominator.
   */
  export class Ratio extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Ratio";

    /** The value of the denominator. */
    set denominator(value: Quantity) {
      this._content["denominator"] = value;
    }

    get denominator(): Quantity {
      return this._content["denominator"] as Quantity;
    }

    /** The value of the numerator. */
    set numerator(value: Quantity) {
      this._content["numerator"] = value;
    }

    get numerator(): Quantity {
      return this._content["numerator"] as Quantity;
    }
  }

  /**
   * RatioRange Type: A range of ratios expressed as a low and high numerator
   * and a denominator.
   */
  export class RatioRange extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/RatioRange";

    /** The value of the denominator. */
    set denominator(value: Quantity) {
      this._content["denominator"] = value;
    }

    get denominator(): Quantity {
      return this._content["denominator"] as Quantity;
    }

    /** The value of the high limit numerator. */
    set highNumerator(value: Quantity) {
      this._content["highNumerator"] = value;
    }

    get highNumerator(): Quantity {
      return this._content["highNumerator"] as Quantity;
    }

    /** The value of the low limit numerator. */
    set lowNumerator(value: Quantity) {
      this._content["lowNumerator"] = value;
    }

    get lowNumerator(): Quantity {
      return this._content["lowNumerator"] as Quantity;
    }
  }

  /** Reference Type: A reference from one resource to another. */
  export class Reference extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Reference";

    /**
     * Plain text narrative that identifies the resource in addition to the
     * resource reference.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * An identifier for the target resource. This is used when there is no way
     * to reference the other resource directly, either because the entity it
     * represents is not available through a FHIR server, or because there is no
     * way for the author of the resource to convert a known identifier to an
     * actual location. There is no requirement that a Reference.identifier
     * point to something that is actually exposed as a FHIR instance, but it
     * SHALL point to a business concept that would be expected to be exposed as
     * a FHIR instance, and that instance would need to be of a FHIR resource
     * type allowed by the reference.
     */
    set identifier(value: Identifier) {
      this._content["identifier"] = value;
    }

    get identifier(): Identifier {
      return this._content["identifier"] as Identifier;
    }

    /**
     * A reference to a location at which the other resource is found. The
     * reference may be a relative reference, in which case it is relative to
     * the service base URL, or an absolute URL that resolves to the location
     * where the resource is found. The reference may be version specific or
     * not. If the reference is not to a FHIR RESTful server, then it should be
     * assumed to be version specific. Internal fragment references (start with
     * '#') refer to contained resources.
     */
    set reference(value: String) {
      this._content["reference"] = value;
    }

    get reference(): String {
      return this._content["reference"] as String;
    }

    /**
     * The expected type of the target of the reference. If both Reference.type
     * and Reference.reference are populated and Reference.reference is a FHIR
     * URL, both SHALL be consistent.
     *
     * The type is the Canonical URL of Resource Definition that is the type
     * this reference refers to. References are URLs that are relative to
     * http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to
     * http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only
     * allowed for logical models (and can only be used in references in logical
     * models, not resources).
     */
    set type(value: Uri) {
      this._content["type"] = value;
    }

    get type(): Uri {
      return this._content["type"] as Uri;
    }
  }

  /**
   * RelatedArtifact Type: Related artifacts such as additional documentation,
   * justification, or bibliographic references.
   */
  export class RelatedArtifact extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/RelatedArtifact";

    /**
     * A bibliographic citation for the related artifact. This text SHOULD be
     * formatted according to an accepted citation format.
     */
    set citation(value: Markdown) {
      this._content["citation"] = value;
    }

    get citation(): Markdown {
      return this._content["citation"] as Markdown;
    }

    /** Provides additional classifiers of the related artifact. */
    set classifier(value: Array<CodeableConcept>) {
      this._content["classifier"] = value;
    }

    get classifier(): Array<CodeableConcept> {
      return this._content["classifier"] as Array<CodeableConcept>;
    }

    /**
     * A brief description of the document or knowledge resource being
     * referenced, suitable for display to a consumer.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * The document being referenced, represented as an attachment. This is
     * exclusive with the resource element.
     */
    set document(value: Attachment) {
      this._content["document"] = value;
    }

    get document(): Attachment {
      return this._content["document"] as Attachment;
    }

    /**
     * A short label that can be used to reference the citation from elsewhere
     * in the containing artifact, such as a footnote index.
     */
    set label(value: String) {
      this._content["label"] = value;
    }

    get label(): String {
      return this._content["label"] as String;
    }

    /** The date of publication of the artifact being referred to. */
    set publicationDate(value: Date) {
      this._content["publicationDate"] = value;
    }

    get publicationDate(): Date {
      return this._content["publicationDate"] as Date;
    }

    /** The publication status of the artifact being referred to. */
    set publicationStatus(value: Code) {
      this._content["publicationStatus"] = value;
    }

    get publicationStatus(): Code {
      return this._content["publicationStatus"] as Code;
    }

    /**
     * The related artifact, such as a library, value set, profile, or other
     * knowledge resource.
     */
    set resource(value: Canonical) {
      this._content["resource"] = value;
    }

    get resource(): Canonical {
      return this._content["resource"] as Canonical;
    }

    /**
     * The related artifact, if the artifact is not a canonical resource, or a
     * resource reference to a canonical resource.
     */
    set resourceReference(value: Reference) {
      this._content["resourceReference"] = value;
    }

    get resourceReference(): Reference {
      return this._content["resourceReference"] as Reference;
    }

    /** The type of relationship to the related artifact. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * SampledData Type: A series of measurements taken by a device, with upper
   * and lower limits. There may be more than one dimension in the data.
   */
  export class SampledData extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/SampledData";

    /** Reference to ConceptMap that defines the codes used in the data. */
    set codeMap(value: Canonical) {
      this._content["codeMap"] = value;
    }

    get codeMap(): Canonical {
      return this._content["codeMap"] as Canonical;
    }

    /**
     * A series of data points which are decimal values or codes separated by a
     * single space (character u20). The special codes "E" (error), "L" (below
     * detection limit) and "U" (above detection limit) are also defined for
     * used in place of decimal values.
     */
    set data(value: String) {
      this._content["data"] = value;
    }

    get data(): String {
      return this._content["data"] as String;
    }

    /**
     * The number of sample points at each time point. If this value is greater
     * than one, then the dimensions will be interlaced - all the sample points
     * for a point in time will be recorded at once.
     */
    set dimensions(value: PositiveInt) {
      this._content["dimensions"] = value;
    }

    get dimensions(): PositiveInt {
      return this._content["dimensions"] as PositiveInt;
    }

    /**
     * A correction factor that is applied to the sampled data points before
     * they are added to the origin.
     */
    set factor(value: Decimal) {
      this._content["factor"] = value;
    }

    get factor(): Decimal {
      return this._content["factor"] as Decimal;
    }

    /**
     * Amount of intervalUnits between samples, e.g. milliseconds for time-based
     * sampling.
     */
    set interval(value: Decimal) {
      this._content["interval"] = value;
    }

    get interval(): Decimal {
      return this._content["interval"] as Decimal;
    }

    /** The measurement unit in which the sample interval is expressed. */
    set intervalUnit(value: Code) {
      this._content["intervalUnit"] = value;
    }

    get intervalUnit(): Code {
      return this._content["intervalUnit"] as Code;
    }

    /**
     * The lower limit of detection of the measured points. This is needed if
     * any of the data points have the value "L" (lower than detection limit).
     */
    set lowerLimit(value: Decimal) {
      this._content["lowerLimit"] = value;
    }

    get lowerLimit(): Decimal {
      return this._content["lowerLimit"] as Decimal;
    }

    /**
     * A series of data points which are decimal values separated by a single
     * space (character u20). The units in which the offsets are expressed are
     * found in intervalUnit. The absolute point at which the measurements begin
     * SHALL be conveyed outside the scope of this datatype, e.g.
     * Observation.effectiveDateTime for a timing offset.
     */
    set offsets(value: String) {
      this._content["offsets"] = value;
    }

    get offsets(): String {
      return this._content["offsets"] as String;
    }

    /**
     * The base quantity that a measured value of zero represents. In addition,
     * this provides the units of the entire measurement series.
     */
    set origin(value: Quantity) {
      this._content["origin"] = value;
    }

    get origin(): Quantity {
      return this._content["origin"] as Quantity;
    }

    /**
     * The upper limit of detection of the measured points. This is needed if
     * any of the data points have the value "U" (higher than detection limit).
     */
    set upperLimit(value: Decimal) {
      this._content["upperLimit"] = value;
    }

    get upperLimit(): Decimal {
      return this._content["upperLimit"] as Decimal;
    }
  }

  /**
   * Signature Type: A signature along with supporting context. The signature
   * may be a digital signature that is cryptographic in nature, or some other
   * signature acceptable to the domain. This other signature may be as simple
   * as a graphical image representing a hand-written signature, or a signature
   * ceremony Different signature approaches have different utilities.
   */
  export class Signature extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Signature";

    /**
     * The base64 encoding of the Signature content. When signature is not
     * recorded electronically this element would be empty.
     */
    set data(value: Base64Binary) {
      this._content["data"] = value;
    }

    get data(): Base64Binary {
      return this._content["data"] as Base64Binary;
    }

    /**
     * A reference to an application-usable description of the identity that is
     * represented by the signature.
     */
    set onBehalfOf(value: Reference) {
      this._content["onBehalfOf"] = value;
    }

    get onBehalfOf(): Reference {
      return this._content["onBehalfOf"] as Reference;
    }

    /**
     * A mime type that indicates the technical format of the signature.
     * Important mime types are application/signature+xml for X ML DigSig,
     * application/jose for JWS, and image/* for a graphical image of a
     * signature, etc.
     */
    set sigFormat(value: Code) {
      this._content["sigFormat"] = value;
    }

    get sigFormat(): Code {
      return this._content["sigFormat"] as Code;
    }

    /**
     * A mime type that indicates the technical format of the target resources
     * signed by the signature.
     */
    set targetFormat(value: Code) {
      this._content["targetFormat"] = value;
    }

    get targetFormat(): Code {
      return this._content["targetFormat"] as Code;
    }

    /**
     * An indication of the reason that the entity signed this document. This
     * may be explicitly included as part of the signature information and can
     * be used when determining accountability for various actions concerning
     * the document.
     */
    set type(value: Array<Coding>) {
      this._content["type"] = value;
    }

    get type(): Array<Coding> {
      return this._content["type"] as Array<Coding>;
    }

    /** When the digital signature was signed. */
    set when(value: Instant) {
      this._content["when"] = value;
    }

    get when(): Instant {
      return this._content["when"] as Instant;
    }

    /**
     * A reference to an application-usable description of the identity that
     * signed (e.g. the signature used their private key).
     */
    set who(value: Reference) {
      this._content["who"] = value;
    }

    get who(): Reference {
      return this._content["who"] as Reference;
    }
  }

  /**
   * Timing Type: Specifies an event that may occur multiple times. Timing
   * schedules are used to record when things are planned, expected or requested
   * to occur. The most common usage is in dosage instructions for medications.
   * They are also used when planning care of various kinds, and may be used for
   * reporting the schedule to which past regular activities were carried out.
   */
  export class Timing extends BackboneType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Timing";

    /**
     * A code for the timing schedule (or just text in code.text). Some codes
     * such as BID are ubiquitous, but many institutions define their own
     * additional codes. If a code is provided, the code is understood to be a
     * complete statement of whatever is specified in the structured timing
     * data, and either the code or the data may be used to interpret the
     * Timing, with the exception that .repeat.bounds still applies over the
     * code (and is not contained in the code).
     */
    set code(value: CodeableConcept) {
      this._content["code"] = value;
    }

    get code(): CodeableConcept {
      return this._content["code"] as CodeableConcept;
    }

    /** Identifies specific times when the event occurs. */
    set event(value: Array<DateTime>) {
      this._content["event"] = value;
    }

    get event(): Array<DateTime> {
      return this._content["event"] as Array<DateTime>;
    }

    /** A set of rules that describe when the event is scheduled. */
    set repeat(value: Element) {
      this._content["repeat"] = value;
    }

    get repeat(): Element {
      return this._content["repeat"] as Element;
    }
  }

  /**
   * TriggerDefinition Type: A description of a triggering event. Triggering
   * events can be named events, data events, or periodic, as determined by the
   * type element.
   */
  export class TriggerDefinition extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/TriggerDefinition";

    /** A code that identifies the event. */
    set code(value: CodeableConcept) {
      this._content["code"] = value;
    }

    get code(): CodeableConcept {
      return this._content["code"] as CodeableConcept;
    }

    /**
     * A boolean-valued expression that is evaluated in the context of the
     * container of the trigger definition and returns whether or not the
     * trigger fires.
     */
    set condition(value: Expression) {
      this._content["condition"] = value;
    }

    get condition(): Expression {
      return this._content["condition"] as Expression;
    }

    /**
     * The triggering data of the event (if this is a data trigger). If more
     * than one data is requirement is specified, then all the data requirements
     * must be true.
     */
    set data(value: Array<DataRequirement>) {
      this._content["data"] = value;
    }

    get data(): Array<DataRequirement> {
      return this._content["data"] as Array<DataRequirement>;
    }

    /**
     * A formal name for the event. This may be an absolute URI that identifies
     * the event formally (e.g. from a trigger registry), or a simple relative
     * URI that identifies the event in a local context.
     */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /**
     * A reference to a SubscriptionTopic resource that defines the event. If
     * this element is provided, no other information about the trigger
     * definition may be supplied.
     */
    set subscriptionTopic(value: Canonical) {
      this._content["subscriptionTopic"] = value;
    }

    get subscriptionTopic(): Canonical {
      return this._content["subscriptionTopic"] as Canonical;
    }

    /** The timing of the event (if this is a periodic trigger). */
    set timing(value: Timing | Reference | Date | DateTime) {
      this._content["timing"] = value;
    }

    get timingTiming(): Timing {
      return this._content["timing"] as Timing;
    }

    get timingReference(): Reference {
      return this._content["timing"] as Reference;
    }

    get timingDate(): Date {
      return this._content["timing"] as Date;
    }

    get timingDateTime(): DateTime {
      return this._content["timing"] as DateTime;
    }

    /** The type of triggering event. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * UsageContext Type: Specifies clinical/business/etc. metadata that can be
   * used to retrieve, index and/or categorize an artifact. This metadata can
   * either be specific to the applicable population (e.g., age category, DRG)
   * or the specific context of care (e.g., venue, care setting, provider of
   * care).
   */
  export class UsageContext extends DataType {
    static url: string = "http://hl7.org/fhir/StructureDefinition/UsageContext";

    /**
     * A code that identifies the type of context being specified by this usage
     * context.
     */
    set code(value: Coding) {
      this._content["code"] = value;
    }

    get code(): Coding {
      return this._content["code"] as Coding;
    }

    /**
     * A value that defines the context specified in this context of use. The
     * interpretation of the value is defined by the code.
     */
    set value(value: CodeableConcept | Quantity | Range | Reference) {
      this._content["value"] = value;
    }

    get valueCodeableConcept(): CodeableConcept {
      return this._content["value"] as CodeableConcept;
    }

    get valueQuantity(): Quantity {
      return this._content["value"] as Quantity;
    }

    get valueRange(): Range {
      return this._content["value"] as Range;
    }

    get valueReference(): Reference {
      return this._content["value"] as Reference;
    }
  }

  /** VirtualServiceDetail Type: Virtual Service Contact Details. */
  export class VirtualServiceDetail extends DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/VirtualServiceDetail";

    /** Address to see alternative connection details. */
    set additionalInfo(value: Array<Url>) {
      this._content["additionalInfo"] = value;
    }

    get additionalInfo(): Array<Url> {
      return this._content["additionalInfo"] as Array<Url>;
    }

    /**
     * What address or number needs to be used for a user to connect to the
     * virtual service to join. The channelType informs as to which datatype is
     * appropriate to use (requires knowledge of the specific type).
     */
    set address(value: Url | String | ContactPoint | ExtendedContactDetail) {
      this._content["address"] = value;
    }

    get addressUrl(): Url {
      return this._content["address"] as Url;
    }

    get addressString(): String {
      return this._content["address"] as String;
    }

    get addressContactPoint(): ContactPoint {
      return this._content["address"] as ContactPoint;
    }

    get addressExtendedContactDetail(): ExtendedContactDetail {
      return this._content["address"] as ExtendedContactDetail;
    }

    /**
     * The type of virtual service to connect to (i.e. Teams, Zoom, Specific VMR
     * technology, WhatsApp).
     */
    set channelType(value: Coding) {
      this._content["channelType"] = value;
    }

    get channelType(): Coding {
      return this._content["channelType"] as Coding;
    }

    /** Maximum number of participants supported by the virtual service. */
    set maxParticipants(value: PositiveInt) {
      this._content["maxParticipants"] = value;
    }

    get maxParticipants(): PositiveInt {
      return this._content["maxParticipants"] as PositiveInt;
    }

    /** Session Key required by the virtual service. */
    set sessionKey(value: String) {
      this._content["sessionKey"] = value;
    }

    get sessionKey(): String {
      return this._content["sessionKey"] as String;
    }
  }

  /**
   * An amount of money. With regard to precision, see [Decimal
   * Precision](datatypes.html#precision)
   */
  export class MoneyQuantity extends Quantity {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MoneyQuantity";
  }

  /** A fixed quantity (no comparator) */
  export class SimpleQuantity extends Quantity {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/SimpleQuantity";
  }

  /**
   * A financial tool for tracking value accrued for a particular purpose. In
   * the healthcare field, used to track charges for a patient, cost centers,
   * etc.
   */
  export class Account extends DomainResource {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Account";

    /**
     * The calculated account balances - these are calculated and processed by
     * the finance system.
     *
     * The balances with a `term` that is not current are usually
     * generated/updated by an invoicing or similar process.
     */
    set balance(value: Array<BackboneElement>) {
      this._content["balance"] = value;
    }

    get balance(): Array<BackboneElement> {
      return this._content["balance"] as Array<BackboneElement>;
    }

    /**
     * The BillingStatus tracks the lifecycle of the account through the billing
     * process. It indicates how transactions are treated when they are
     * allocated to the account.
     */
    set billingStatus(value: CodeableConcept) {
      this._content["billingStatus"] = value;
    }

    get billingStatus(): CodeableConcept {
      return this._content["billingStatus"] as CodeableConcept;
    }

    /** Time the balance amount was calculated. */
    set calculatedAt(value: Instant) {
      this._content["calculatedAt"] = value;
    }

    get calculatedAt(): Instant {
      return this._content["calculatedAt"] as Instant;
    }

    /**
     * The party(s) that are responsible for covering the payment of this
     * account, and what order should they be applied to the account.
     */
    set coverage(value: Array<BackboneElement>) {
      this._content["coverage"] = value;
    }

    get coverage(): Array<BackboneElement> {
      return this._content["coverage"] as Array<BackboneElement>;
    }

    /** The default currency for the account. */
    set currency(value: CodeableConcept) {
      this._content["currency"] = value;
    }

    get currency(): CodeableConcept {
      return this._content["currency"] as CodeableConcept;
    }

    /**
     * Provides additional information about what the account tracks and how it
     * is used.
     */
    set description(value: Markdown) {
      this._content["description"] = value;
    }

    get description(): Markdown {
      return this._content["description"] as Markdown;
    }

    /**
     * When using an account for billing a specific Encounter the set of
     * diagnoses that are relevant for billing are stored here on the account
     * where they are able to be sequenced appropriately prior to processing to
     * produce claim(s).
     */
    set diagnosis(value: Array<BackboneElement>) {
      this._content["diagnosis"] = value;
    }

    get diagnosis(): Array<BackboneElement> {
      return this._content["diagnosis"] as Array<BackboneElement>;
    }

    /**
     * The parties responsible for balancing the account if other payment
     * options fall short.
     */
    set guarantor(value: Array<BackboneElement>) {
      this._content["guarantor"] = value;
    }

    get guarantor(): Array<BackboneElement> {
      return this._content["guarantor"] as Array<BackboneElement>;
    }

    /**
     * Unique identifier used to reference the account. Might or might not be
     * intended for human use (e.g. credit card number).
     */
    set identifier(value: Array<Identifier>) {
      this._content["identifier"] = value;
    }

    get identifier(): Array<Identifier> {
      return this._content["identifier"] as Array<Identifier>;
    }

    /** Name used for the account when displaying it to humans in reports, etc. */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /**
     * Indicates the service area, hospital, department, etc. with
     * responsibility for managing the Account.
     */
    set owner(value: Reference) {
      this._content["owner"] = value;
    }

    get owner(): Reference {
      return this._content["owner"] as Reference;
    }

    /**
     * When using an account for billing a specific Encounter the set of
     * procedures that are relevant for billing are stored here on the account
     * where they are able to be sequenced appropriately prior to processing to
     * produce claim(s).
     */
    set procedure(value: Array<BackboneElement>) {
      this._content["procedure"] = value;
    }

    get procedure(): Array<BackboneElement> {
      return this._content["procedure"] as Array<BackboneElement>;
    }

    /** Other associated accounts related to this account. */
    set relatedAccount(value: Array<BackboneElement>) {
      this._content["relatedAccount"] = value;
    }

    get relatedAccount(): Array<BackboneElement> {
      return this._content["relatedAccount"] as Array<BackboneElement>;
    }

    /** The date range of services associated with this account. */
    set servicePeriod(value: Period) {
      this._content["servicePeriod"] = value;
    }

    get servicePeriod(): Period {
      return this._content["servicePeriod"] as Period;
    }

    /** Indicates whether the account is presently used/usable or not. */
    set status(value: Code) {
      this._content["status"] = value;
    }

    get status(): Code {
      return this._content["status"] as Code;
    }

    /**
     * Identifies the entity which incurs the expenses. While the immediate
     * recipients of services or goods might be entities related to the subject,
     * the expenses were ultimately incurred by the subject of the Account.
     */
    set subject(value: Array<Reference>) {
      this._content["subject"] = value;
    }

    get subject(): Array<Reference> {
      return this._content["subject"] as Array<Reference>;
    }

    /** Categorizes the account for reporting and searching purposes. */
    set type(value: CodeableConcept) {
      this._content["type"] = value;
    }

    get type(): CodeableConcept {
      return this._content["type"] as CodeableConcept;
    }
  }
}
