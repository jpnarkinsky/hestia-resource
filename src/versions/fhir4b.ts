// Autogenerated by src/generate.  Do not edit!
namespace fhir4b {
  export type TElement =
    | string
    | number
    | boolean
    | Address
    | Address[]
    | Age
    | Age[]
    | Annotation
    | Annotation[]
    | Attachment
    | Attachment[]
    | BackboneElement
    | BackboneElement[]
    | Base64Binary
    | Base64Binary[]
    | Boolean
    | Boolean[]
    | Canonical
    | Canonical[]
    | Code
    | Code[]
    | CodeableConcept
    | CodeableConcept[]
    | CodeableReference
    | CodeableReference[]
    | Coding
    | Coding[]
    | ContactDetail
    | ContactDetail[]
    | ContactPoint
    | ContactPoint[]
    | Contributor
    | Contributor[]
    | Count
    | Count[]
    | DataRequirement
    | DataRequirement[]
    | Date
    | Date[]
    | DateTime
    | DateTime[]
    | Decimal
    | Decimal[]
    | Distance
    | Distance[]
    | Dosage
    | Dosage[]
    | Duration
    | Duration[]
    | Element
    | Element[]
    | ElementDefinition
    | ElementDefinition[]
    | Expression
    | Expression[]
    | Extension
    | Extension[]
    | HumanName
    | HumanName[]
    | Id
    | Id[]
    | Identifier
    | Identifier[]
    | Instant
    | Instant[]
    | Integer
    | Integer[]
    | Markdown
    | Markdown[]
    | MarketingStatus
    | MarketingStatus[]
    | Meta
    | Meta[]
    | Money
    | Money[]
    | MoneyQuantity
    | MoneyQuantity[]
    | Narrative
    | Narrative[]
    | Oid
    | Oid[]
    | ParameterDefinition
    | ParameterDefinition[]
    | Period
    | Period[]
    | Population
    | Population[]
    | PositiveInt
    | PositiveInt[]
    | ProdCharacteristic
    | ProdCharacteristic[]
    | ProductShelfLife
    | ProductShelfLife[]
    | Quantity
    | Quantity[]
    | Range
    | Range[]
    | Ratio
    | Ratio[]
    | RatioRange
    | RatioRange[]
    | Reference
    | Reference[]
    | RelatedArtifact
    | RelatedArtifact[]
    | SampledData
    | SampledData[]
    | Signature
    | Signature[]
    | SimpleQuantity
    | SimpleQuantity[]
    | String
    | String[]
    | Time
    | Time[]
    | Timing
    | Timing[]
    | TriggerDefinition
    | TriggerDefinition[]
    | UnsignedInt
    | UnsignedInt[]
    | Uri
    | Uri[]
    | Url
    | Url[]
    | UsageContext
    | UsageContext[]
    | Uuid
    | Uuid[]
    | Xhtml
    | Xhtml[];

  export class Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Element/Base";
  }

  /** Base class for all data elements */
  abstract class Element extends Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Element";
  }

  export class DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/Element/DataType";
  }

  export class Resource {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/Element/Resource";
  }

  /**
   * Base StructureDefinition for BackboneElement Type: Base definition for all
   * elements that are defined inside a resource - but not those in a data
   * type.
   */
  export abstract class BackboneElement extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/BackboneElement";

    /**
     * May be used to represent additional information that is not part of the
     * basic definition of the element and that modifies the understanding of
     * the element in which it is contained and/or the understanding of the
     * containing element's descendants. Usually modifier elements provide
     * negation or qualification. To make the use of extensions safe and
     * manageable, there is a strict set of governance applied to the definition
     * and use of extensions. Though any implementer can define an extension,
     * there is a set of requirements that SHALL be met as part of the
     * definition of the extension. Applications processing a resource are
     * required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    set modifierExtension(value: Array<Extension>) {
      this._content["modifierExtension"] = value;
    }

    get modifierExtension(): Array<Extension> {
      return this._content["modifierExtension"] as Array<Extension>;
    }
  }

  class Base64Binary extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/base64Binary";
  }

  class Boolean extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/boolean";
  }

  class Uri extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/uri";
  }

  class Canonical extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/canonical";
  }

  class String extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/string";
  }

  class Code extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/code";
  }

  class Date extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/date";
  }

  class DateTime extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/dateTime";
  }

  class Decimal extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/decimal";
  }

  class Id extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/id";
  }

  class Instant extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/instant";
  }

  class Integer extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/integer";
  }

  class Markdown extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/markdown";
  }

  class Oid extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/oid";
  }

  class PositiveInt extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/positiveInt";
  }

  class Time extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/time";
  }

  class UnsignedInt extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/unsignedInt";
  }

  class Url extends Element {
    static canonicalUrl: string = "http://hl7.org/fhir/StructureDefinition/url";
  }

  class Uuid extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/uuid";
  }

  class Xhtml extends Element {
    static canonicalUrl: string =
      "http://hl7.org/fhir/StructureDefinition/xhtml";
  }

  /**
   * Base StructureDefinition for Address Type: An address expressed using
   * postal conventions (as opposed to GPS or other location definition
   * formats). This data type may be used to convey addresses for use in
   * delivering mail as well as for visiting locations which might not be valid
   * for mail delivery. There are a variety of postal address formats defined
   * around the world.
   */
  export class Address extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Address";

    /**
     * The name of the city, town, suburb, village or other community or
     * delivery center.
     */
    set city(value: String) {
      this._content["city"] = value;
    }

    get city(): String {
      return this._content["city"] as String;
    }

    /** Country - a nation as commonly understood or generally accepted. */
    set country(value: String) {
      this._content["country"] = value;
    }

    get country(): String {
      return this._content["country"] as String;
    }

    /** The name of the administrative area (county). */
    set district(value: String) {
      this._content["district"] = value;
    }

    get district(): String {
      return this._content["district"] as String;
    }

    /**
     * This component contains the house number, apartment number, street name,
     * street direction, P.O. Box number, delivery hints, and similar address
     * information.
     */
    set line(value: Array<String>) {
      this._content["line"] = value;
    }

    get line(): Array<String> {
      return this._content["line"] as Array<String>;
    }

    /** Time period when address was/is in use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /** A postal code designating a region defined by the postal service. */
    set postalCode(value: String) {
      this._content["postalCode"] = value;
    }

    get postalCode(): String {
      return this._content["postalCode"] as String;
    }

    /**
     * Sub-unit of a country with limited sovereignty in a federally organized
     * country. A code may be used if codes are in common use (e.g. US 2 letter
     * state codes).
     */
    set state(value: String) {
      this._content["state"] = value;
    }

    get state(): String {
      return this._content["state"] as String;
    }

    /**
     * Specifies the entire address as it should be displayed e.g. on a postal
     * label. This may be provided instead of or as well as the specific parts.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /**
     * Distinguishes between physical addresses (those you can visit) and
     * mailing addresses (e.g. PO Boxes and care-of addresses). Most addresses
     * are both.
     */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /** The purpose of this address. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Base StructureDefinition for Quantity Type: A measured amount (or an amount
   * that can potentially be measured). Note that measured amounts include
   * amounts that are not precisely quantified, including amounts involving
   * arbitrary units and floating currencies.
   */
  export class Quantity extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Quantity";

    /**
     * A computer processable form of the unit in some unit representation
     * system.
     */
    set code(value: Code) {
      this._content["code"] = value;
    }

    get code(): Code {
      return this._content["code"] as Code;
    }

    /**
     * How the value should be understood and represented - whether the actual
     * value is greater or less than the stated value due to measurement issues;
     * e.g. if the comparator is "<" , then the real value is < stated value.
     */
    set comparator(value: Code) {
      this._content["comparator"] = value;
    }

    get comparator(): Code {
      return this._content["comparator"] as Code;
    }

    /**
     * The identification of the system that provides the coded form of the
     * unit.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /** A human-readable form of the unit. */
    set unit(value: String) {
      this._content["unit"] = value;
    }

    get unit(): String {
      return this._content["unit"] as String;
    }

    /**
     * The value of the measured amount. The value includes an implicit
     * precision in the presentation of the value.
     */
    set value(value: Decimal) {
      this._content["value"] = value;
    }

    get value(): Decimal {
      return this._content["value"] as Decimal;
    }
  }

  /**
   * Base StructureDefinition for Age Type: A duration of time during which an
   * organism (or a process) has existed.
   */
  export class Age extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Age";
  }

  /**
   * Base StructureDefinition for Annotation Type: A text note which also
   * contains information about who made the statement and when.
   */
  export class Annotation extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Annotation";

    /** The individual responsible for making the annotation. */
    set author(value: Reference | String) {
      this._content["author"] = value;
    }

    get authorReference(): Reference {
      return this._content["author"] as Reference;
    }

    get authorString(): String {
      return this._content["author"] as String;
    }

    /** The text of the annotation in markdown format. */
    set text(value: Markdown) {
      this._content["text"] = value;
    }

    get text(): Markdown {
      return this._content["text"] as Markdown;
    }

    /** Indicates when this particular annotation was made. */
    set time(value: DateTime) {
      this._content["time"] = value;
    }

    get time(): DateTime {
      return this._content["time"] as DateTime;
    }
  }

  /**
   * Base StructureDefinition for Attachment Type: For referring to data content
   * defined in other formats.
   */
  export class Attachment extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Attachment";

    /**
     * Identifies the type of the data in the attachment and allows a method to
     * be chosen to interpret or render the data. Includes mime type parameters
     * such as charset where appropriate.
     */
    set contentType(value: Code) {
      this._content["contentType"] = value;
    }

    get contentType(): Code {
      return this._content["contentType"] as Code;
    }

    /** The date that the attachment was first created. */
    set creation(value: DateTime) {
      this._content["creation"] = value;
    }

    get creation(): DateTime {
      return this._content["creation"] as DateTime;
    }

    /** The actual data of the attachment - a sequence of bytes, base64 encoded. */
    set data(value: Base64Binary) {
      this._content["data"] = value;
    }

    get data(): Base64Binary {
      return this._content["data"] as Base64Binary;
    }

    /** The calculated hash of the data using SHA-1. Represented using base64. */
    set hash(value: Base64Binary) {
      this._content["hash"] = value;
    }

    get hash(): Base64Binary {
      return this._content["hash"] as Base64Binary;
    }

    /**
     * The human language of the content. The value can be any valid value
     * according to BCP 47.
     */
    set language(value: Code) {
      this._content["language"] = value;
    }

    get language(): Code {
      return this._content["language"] as Code;
    }

    /**
     * The number of bytes of data that make up this attachment (before base64
     * encoding, if that is done).
     */
    set size(value: UnsignedInt) {
      this._content["size"] = value;
    }

    get size(): UnsignedInt {
      return this._content["size"] as UnsignedInt;
    }

    /** A label or set of text to display in place of the data. */
    set title(value: String) {
      this._content["title"] = value;
    }

    get title(): String {
      return this._content["title"] as String;
    }

    /** A location where the data can be accessed. */
    set url(value: Url) {
      this._content["url"] = value;
    }

    get url(): Url {
      return this._content["url"] as Url;
    }
  }

  /**
   * Base StructureDefinition for CodeableConcept Type: A concept that may be
   * defined by a formal reference to a terminology or ontology or may be
   * provided by text.
   */
  export class CodeableConcept extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/CodeableConcept";

    /** A reference to a code defined by a terminology system. */
    set coding(value: Array<Coding>) {
      this._content["coding"] = value;
    }

    get coding(): Array<Coding> {
      return this._content["coding"] as Array<Coding>;
    }

    /**
     * A human language representation of the concept as seen/selected/uttered
     * by the user who entered the data and/or which represents the intended
     * meaning of the user.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }
  }

  /**
   * Base StructureDefinition for CodeableReference Type: A reference to a
   * resource (by instance), or instead, a reference to a concept defined in a
   * terminology or ontology (by class).
   */
  export class CodeableReference extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/CodeableReference";

    /**
     * A reference to a concept - e.g. the information is identified by its
     * general class to the degree of precision found in the terminology.
     */
    set concept(value: CodeableConcept) {
      this._content["concept"] = value;
    }

    get concept(): CodeableConcept {
      return this._content["concept"] as CodeableConcept;
    }

    /**
     * A reference to a resource the provides exact details about the
     * information being referenced.
     */
    set reference(value: Reference) {
      this._content["reference"] = value;
    }

    get reference(): Reference {
      return this._content["reference"] as Reference;
    }
  }

  /**
   * Base StructureDefinition for Coding Type: A reference to a code defined by
   * a terminology system.
   */
  export class Coding extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Coding";

    /**
     * A symbol in syntax defined by the system. The symbol may be a predefined
     * code or an expression in a syntax defined by the coding system (e.g.
     * post-coordination).
     */
    set code(value: Code) {
      this._content["code"] = value;
    }

    get code(): Code {
      return this._content["code"] as Code;
    }

    /**
     * A representation of the meaning of the code in the system, following the
     * rules of the system.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * The identification of the code system that defines the meaning of the
     * symbol in the code.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /**
     * Indicates that this coding was chosen by a user directly - e.g. off a
     * pick list of available items (codes or displays).
     */
    set userSelected(value: Boolean) {
      this._content["userSelected"] = value;
    }

    get userSelected(): Boolean {
      return this._content["userSelected"] as Boolean;
    }

    /**
     * The version of the code system which was used when choosing this code.
     * Note that a well-maintained code system does not need the version
     * reported, because the meaning of codes is consistent across versions.
     * However this cannot consistently be assured, and when the meaning is not
     * guaranteed to be consistent, the version SHOULD be exchanged.
     */
    set version(value: String) {
      this._content["version"] = value;
    }

    get version(): String {
      return this._content["version"] as String;
    }
  }

  /**
   * Base StructureDefinition for ContactDetail Type: Specifies contact
   * information for a person or organization.
   */
  export class ContactDetail extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ContactDetail";

    /** The name of an individual to contact. */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /**
     * The contact details for the individual (if a name was provided) or the
     * organization.
     */
    set telecom(value: Array<ContactPoint>) {
      this._content["telecom"] = value;
    }

    get telecom(): Array<ContactPoint> {
      return this._content["telecom"] as Array<ContactPoint>;
    }
  }

  /**
   * Base StructureDefinition for ContactPoint Type: Details for all kinds of
   * technology mediated contact points for a person or organization, including
   * telephone, email, etc.
   */
  export class ContactPoint extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/ContactPoint";

    /** Time period when the contact point was/is in use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Specifies a preferred order in which to use a set of contacts.
     * ContactPoints with lower rank values are more preferred than those with
     * higher rank values.
     */
    set rank(value: PositiveInt) {
      this._content["rank"] = value;
    }

    get rank(): PositiveInt {
      return this._content["rank"] as PositiveInt;
    }

    /**
     * Telecommunications form for contact point - what communications system is
     * required to make use of the contact.
     */
    set system(value: Code) {
      this._content["system"] = value;
    }

    get system(): Code {
      return this._content["system"] as Code;
    }

    /** Identifies the purpose for the contact point. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }

    /**
     * The actual contact point details, in a form that is meaningful to the
     * designated communication system (i.e. phone number or email address).
     */
    set value(value: String) {
      this._content["value"] = value;
    }

    get value(): String {
      return this._content["value"] as String;
    }
  }

  /**
   * Base StructureDefinition for Contributor Type: A contributor to the content
   * of a knowledge asset, including authors, editors, reviewers, and
   * endorsers.
   */
  export class Contributor extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Contributor";

    /**
     * Contact details to assist a user in finding and communicating with the
     * contributor.
     */
    set contact(value: Array<ContactDetail>) {
      this._content["contact"] = value;
    }

    get contact(): Array<ContactDetail> {
      return this._content["contact"] as Array<ContactDetail>;
    }

    /**
     * The name of the individual or organization responsible for the
     * contribution.
     */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /** The type of contributor. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * Base StructureDefinition for Count Type: A measured amount (or an amount
   * that can potentially be measured). Note that measured amounts include
   * amounts that are not precisely quantified, including amounts involving
   * arbitrary units and floating currencies.
   */
  export class Count extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Count";
  }

  /**
   * Base StructureDefinition for DataRequirement Type: Describes a required
   * data item for evaluation in terms of the type of data, and optional code or
   * date-based filters of the data.
   */
  export class DataRequirement extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/DataRequirement";

    /**
     * Code filters specify additional constraints on the data, specifying the
     * value set of interest for a particular element of the data. Each code
     * filter defines an additional constraint on the data, i.e. code filters
     * are AND'ed, not OR'ed.
     */
    set codeFilter(value: Array<Element>) {
      this._content["codeFilter"] = value;
    }

    get codeFilter(): Array<Element> {
      return this._content["codeFilter"] as Array<Element>;
    }

    /**
     * Date filters specify additional constraints on the data in terms of the
     * applicable date range for specific elements. Each date filter specifies
     * an additional constraint on the data, i.e. date filters are AND'ed, not
     * OR'ed.
     */
    set dateFilter(value: Array<Element>) {
      this._content["dateFilter"] = value;
    }

    get dateFilter(): Array<Element> {
      return this._content["dateFilter"] as Array<Element>;
    }

    /**
     * Specifies a maximum number of results that are required (uses the _count
     * search parameter).
     */
    set limit(value: PositiveInt) {
      this._content["limit"] = value;
    }

    get limit(): PositiveInt {
      return this._content["limit"] as PositiveInt;
    }

    /**
     * Indicates that specific elements of the type are referenced by the
     * knowledge module and must be supported by the consumer in order to obtain
     * an effective evaluation. This does not mean that a value is required for
     * this element, only that the consuming system must understand the element
     * and be able to provide values for it if they are available.
     *
     * The value of mustSupport SHALL be a FHIRPath resolveable on the type of
     * the DataRequirement. The path SHALL consist only of identifiers, constant
     * indexers, and .resolve() (see the [Simple FHIRPath
     * Profile](fhirpath.html#simple) for full details).
     */
    set mustSupport(value: Array<String>) {
      this._content["mustSupport"] = value;
    }

    get mustSupport(): Array<String> {
      return this._content["mustSupport"] as Array<String>;
    }

    /**
     * The profile of the required data, specified as the uri of the profile
     * definition.
     */
    set profile(value: Array<Canonical>) {
      this._content["profile"] = value;
    }

    get profile(): Array<Canonical> {
      return this._content["profile"] as Array<Canonical>;
    }

    /** Specifies the order of the results to be returned. */
    set sort(value: Array<Element>) {
      this._content["sort"] = value;
    }

    get sort(): Array<Element> {
      return this._content["sort"] as Array<Element>;
    }

    /**
     * The intended subjects of the data requirement. If this element is not
     * provided, a Patient subject is assumed.
     */
    set subject(value: CodeableConcept | Reference) {
      this._content["subject"] = value;
    }

    get subjectCodeableConcept(): CodeableConcept {
      return this._content["subject"] as CodeableConcept;
    }

    get subjectReference(): Reference {
      return this._content["subject"] as Reference;
    }

    /**
     * The type of the required data, specified as the type name of a resource.
     * For profiles, this value is set to the type of the base resource of the
     * profile.
     */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * Base StructureDefinition for Distance Type: A length - a value with a unit
   * that is a physical distance.
   */
  export class Distance extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Distance";
  }

  /**
   * Base StructureDefinition for Dosage Type: Indicates how the medication
   * is/was taken or should be taken by the patient.
   */
  export class Dosage extends BackboneElement {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Dosage";

    /**
     * Supplemental instructions to the patient on how to take the medication
     * (e.g. "with meals" or"take half to one hour before food") or warnings for
     * the patient about the medication (e.g. "may cause drowsiness" or "avoid
     * exposure of skin to direct sunlight or sunlamps").
     */
    set additionalInstruction(value: Array<CodeableConcept>) {
      this._content["additionalInstruction"] = value;
    }

    get additionalInstruction(): Array<CodeableConcept> {
      return this._content["additionalInstruction"] as Array<CodeableConcept>;
    }

    /**
     * Indicates whether the Medication is only taken when needed within a
     * specific dosing schedule (Boolean option), or it indicates the
     * precondition for taking the Medication (CodeableConcept).
     */
    set asNeeded(value: Boolean | CodeableConcept) {
      this._content["asNeeded"] = value;
    }

    get asNeededBoolean(): Boolean {
      return this._content["asNeeded"] as Boolean;
    }

    get asNeededCodeableConcept(): CodeableConcept {
      return this._content["asNeeded"] as CodeableConcept;
    }

    /** The amount of medication administered. */
    set doseAndRate(value: Array<Element>) {
      this._content["doseAndRate"] = value;
    }

    get doseAndRate(): Array<Element> {
      return this._content["doseAndRate"] as Array<Element>;
    }

    /** Upper limit on medication per administration. */
    set maxDosePerAdministration(value: Quantity) {
      this._content["maxDosePerAdministration"] = value;
    }

    get maxDosePerAdministration(): Quantity {
      return this._content["maxDosePerAdministration"] as Quantity;
    }

    /** Upper limit on medication per lifetime of the patient. */
    set maxDosePerLifetime(value: Quantity) {
      this._content["maxDosePerLifetime"] = value;
    }

    get maxDosePerLifetime(): Quantity {
      return this._content["maxDosePerLifetime"] as Quantity;
    }

    /** Upper limit on medication per unit of time. */
    set maxDosePerPeriod(value: Ratio) {
      this._content["maxDosePerPeriod"] = value;
    }

    get maxDosePerPeriod(): Ratio {
      return this._content["maxDosePerPeriod"] as Ratio;
    }

    /** Technique for administering medication. */
    set method(value: CodeableConcept) {
      this._content["method"] = value;
    }

    get method(): CodeableConcept {
      return this._content["method"] as CodeableConcept;
    }

    /** Instructions in terms that are understood by the patient or consumer. */
    set patientInstruction(value: String) {
      this._content["patientInstruction"] = value;
    }

    get patientInstruction(): String {
      return this._content["patientInstruction"] as String;
    }

    /** How drug should enter body. */
    set route(value: CodeableConcept) {
      this._content["route"] = value;
    }

    get route(): CodeableConcept {
      return this._content["route"] as CodeableConcept;
    }

    /**
     * Indicates the order in which the dosage instructions should be applied or
     * interpreted.
     */
    set sequence(value: Integer) {
      this._content["sequence"] = value;
    }

    get sequence(): Integer {
      return this._content["sequence"] as Integer;
    }

    /** Body site to administer to. */
    set site(value: CodeableConcept) {
      this._content["site"] = value;
    }

    get site(): CodeableConcept {
      return this._content["site"] as CodeableConcept;
    }

    /** Free text dosage instructions e.g. SIG. */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /** When medication should be administered. */
    set timing(value: Timing) {
      this._content["timing"] = value;
    }

    get timing(): Timing {
      return this._content["timing"] as Timing;
    }
  }

  /** Base StructureDefinition for Duration Type: A length of time. */
  export class Duration extends Quantity {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Duration";
  }

  /**
   * Base StructureDefinition for ElementDefinition Type: Captures constraints
   * on each element within the resource, profile, or extension.
   */
  export class ElementDefinition extends BackboneElement {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ElementDefinition";

    /** Identifies additional names by which this element might also be known. */
    set alias(value: Array<String>) {
      this._content["alias"] = value;
    }

    get alias(): Array<String> {
      return this._content["alias"] as Array<String>;
    }

    /**
     * Information about the base definition of the element, provided to make it
     * unnecessary for tools to trace the deviation of the element through the
     * derived and related profiles. When the element definition is not the
     * original definition of an element - i.g. either in a constraint on
     * another type, or for elements from a super type in a snap shot - then the
     * information in provided in the element definition may be different to the
     * base definition. On the original definition of the element, it will be
     * same.
     */
    set base(value: Element) {
      this._content["base"] = value;
    }

    get base(): Element {
      return this._content["base"] as Element;
    }

    /**
     * Binds to a value set if this element is coded (code, Coding,
     * CodeableConcept, Quantity), or the data types (string, uri).
     */
    set binding(value: Element) {
      this._content["binding"] = value;
    }

    get binding(): Element {
      return this._content["binding"] as Element;
    }

    /**
     * A code that has the same meaning as the element in a particular
     * terminology.
     */
    set code(value: Array<Coding>) {
      this._content["code"] = value;
    }

    get code(): Array<Coding> {
      return this._content["code"] as Array<Coding>;
    }

    /**
     * Explanatory notes and implementation guidance about the data element,
     * including notes about how to use the data properly, exceptions to proper
     * use, etc. (Note: The text you are reading is specified in
     * ElementDefinition.comment).
     */
    set comment(value: Markdown) {
      this._content["comment"] = value;
    }

    get comment(): Markdown {
      return this._content["comment"] as Markdown;
    }

    /**
     * A reference to an invariant that may make additional statements about the
     * cardinality or value in the instance.
     */
    set condition(value: Array<Id>) {
      this._content["condition"] = value;
    }

    get condition(): Array<Id> {
      return this._content["condition"] as Array<Id>;
    }

    /**
     * Formal constraints such as co-occurrence and other constraints that can
     * be computationally evaluated within the context of the instance.
     */
    set constraint(value: Array<Element>) {
      this._content["constraint"] = value;
    }

    get constraint(): Array<Element> {
      return this._content["constraint"] as Array<Element>;
    }

    /**
     * Identifies an element defined elsewhere in the definition whose content
     * rules should be applied to the current element. ContentReferences bring
     * across all the rules that are in the ElementDefinition for the element,
     * including definitions, cardinality constraints, bindings, invariants
     * etc.
     */
    set contentReference(value: Uri) {
      this._content["contentReference"] = value;
    }

    get contentReference(): Uri {
      return this._content["contentReference"] as Uri;
    }

    /**
     * The value that should be used if there is no value stated in the instance
     * (e.g. 'if not otherwise specified, the abstract is false').
     */
    set defaultValue(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | Contributor
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Dosage,
    ) {
      this._content["defaultValue"] = value;
    }

    get defaultValueBase64Binary(): Base64Binary {
      return this._content["defaultValue"] as Base64Binary;
    }

    get defaultValueBoolean(): Boolean {
      return this._content["defaultValue"] as Boolean;
    }

    get defaultValueCanonical(): Canonical {
      return this._content["defaultValue"] as Canonical;
    }

    get defaultValueCode(): Code {
      return this._content["defaultValue"] as Code;
    }

    get defaultValueDate(): Date {
      return this._content["defaultValue"] as Date;
    }

    get defaultValueDateTime(): DateTime {
      return this._content["defaultValue"] as DateTime;
    }

    get defaultValueDecimal(): Decimal {
      return this._content["defaultValue"] as Decimal;
    }

    get defaultValueId(): Id {
      return this._content["defaultValue"] as Id;
    }

    get defaultValueInstant(): Instant {
      return this._content["defaultValue"] as Instant;
    }

    get defaultValueInteger(): Integer {
      return this._content["defaultValue"] as Integer;
    }

    get defaultValueMarkdown(): Markdown {
      return this._content["defaultValue"] as Markdown;
    }

    get defaultValueOid(): Oid {
      return this._content["defaultValue"] as Oid;
    }

    get defaultValuePositiveInt(): PositiveInt {
      return this._content["defaultValue"] as PositiveInt;
    }

    get defaultValueString(): String {
      return this._content["defaultValue"] as String;
    }

    get defaultValueTime(): Time {
      return this._content["defaultValue"] as Time;
    }

    get defaultValueUnsignedInt(): UnsignedInt {
      return this._content["defaultValue"] as UnsignedInt;
    }

    get defaultValueUri(): Uri {
      return this._content["defaultValue"] as Uri;
    }

    get defaultValueUrl(): Url {
      return this._content["defaultValue"] as Url;
    }

    get defaultValueUuid(): Uuid {
      return this._content["defaultValue"] as Uuid;
    }

    get defaultValueAddress(): Address {
      return this._content["defaultValue"] as Address;
    }

    get defaultValueAge(): Age {
      return this._content["defaultValue"] as Age;
    }

    get defaultValueAnnotation(): Annotation {
      return this._content["defaultValue"] as Annotation;
    }

    get defaultValueAttachment(): Attachment {
      return this._content["defaultValue"] as Attachment;
    }

    get defaultValueCodeableConcept(): CodeableConcept {
      return this._content["defaultValue"] as CodeableConcept;
    }

    get defaultValueCodeableReference(): CodeableReference {
      return this._content["defaultValue"] as CodeableReference;
    }

    get defaultValueCoding(): Coding {
      return this._content["defaultValue"] as Coding;
    }

    get defaultValueContactPoint(): ContactPoint {
      return this._content["defaultValue"] as ContactPoint;
    }

    get defaultValueCount(): Count {
      return this._content["defaultValue"] as Count;
    }

    get defaultValueDistance(): Distance {
      return this._content["defaultValue"] as Distance;
    }

    get defaultValueDuration(): Duration {
      return this._content["defaultValue"] as Duration;
    }

    get defaultValueHumanName(): HumanName {
      return this._content["defaultValue"] as HumanName;
    }

    get defaultValueIdentifier(): Identifier {
      return this._content["defaultValue"] as Identifier;
    }

    get defaultValueMoney(): Money {
      return this._content["defaultValue"] as Money;
    }

    get defaultValuePeriod(): Period {
      return this._content["defaultValue"] as Period;
    }

    get defaultValueQuantity(): Quantity {
      return this._content["defaultValue"] as Quantity;
    }

    get defaultValueRange(): Range {
      return this._content["defaultValue"] as Range;
    }

    get defaultValueRatio(): Ratio {
      return this._content["defaultValue"] as Ratio;
    }

    get defaultValueRatioRange(): RatioRange {
      return this._content["defaultValue"] as RatioRange;
    }

    get defaultValueReference(): Reference {
      return this._content["defaultValue"] as Reference;
    }

    get defaultValueSampledData(): SampledData {
      return this._content["defaultValue"] as SampledData;
    }

    get defaultValueSignature(): Signature {
      return this._content["defaultValue"] as Signature;
    }

    get defaultValueTiming(): Timing {
      return this._content["defaultValue"] as Timing;
    }

    get defaultValueContactDetail(): ContactDetail {
      return this._content["defaultValue"] as ContactDetail;
    }

    get defaultValueContributor(): Contributor {
      return this._content["defaultValue"] as Contributor;
    }

    get defaultValueDataRequirement(): DataRequirement {
      return this._content["defaultValue"] as DataRequirement;
    }

    get defaultValueExpression(): Expression {
      return this._content["defaultValue"] as Expression;
    }

    get defaultValueParameterDefinition(): ParameterDefinition {
      return this._content["defaultValue"] as ParameterDefinition;
    }

    get defaultValueRelatedArtifact(): RelatedArtifact {
      return this._content["defaultValue"] as RelatedArtifact;
    }

    get defaultValueTriggerDefinition(): TriggerDefinition {
      return this._content["defaultValue"] as TriggerDefinition;
    }

    get defaultValueUsageContext(): UsageContext {
      return this._content["defaultValue"] as UsageContext;
    }

    get defaultValueDosage(): Dosage {
      return this._content["defaultValue"] as Dosage;
    }

    /**
     * Provides a complete explanation of the meaning of the data element for
     * human readability. For the case of elements derived from existing
     * elements (e.g. constraints), the definition SHALL be consistent with the
     * base definition, but convey the meaning of the element in the particular
     * context of use of the resource. (Note: The text you are reading is
     * specified in ElementDefinition.definition).
     */
    set definition(value: Markdown) {
      this._content["definition"] = value;
    }

    get definition(): Markdown {
      return this._content["definition"] as Markdown;
    }

    /**
     * A sample value for this element demonstrating the type of information
     * that would typically be found in the element.
     */
    set example(value: Array<Element>) {
      this._content["example"] = value;
    }

    get example(): Array<Element> {
      return this._content["example"] as Array<Element>;
    }

    /**
     * Specifies a value that SHALL be exactly the value for this element in the
     * instance. For purposes of comparison, non-significant whitespace is
     * ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    set fixed(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | Contributor
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Dosage,
    ) {
      this._content["fixed"] = value;
    }

    get fixedBase64Binary(): Base64Binary {
      return this._content["fixed"] as Base64Binary;
    }

    get fixedBoolean(): Boolean {
      return this._content["fixed"] as Boolean;
    }

    get fixedCanonical(): Canonical {
      return this._content["fixed"] as Canonical;
    }

    get fixedCode(): Code {
      return this._content["fixed"] as Code;
    }

    get fixedDate(): Date {
      return this._content["fixed"] as Date;
    }

    get fixedDateTime(): DateTime {
      return this._content["fixed"] as DateTime;
    }

    get fixedDecimal(): Decimal {
      return this._content["fixed"] as Decimal;
    }

    get fixedId(): Id {
      return this._content["fixed"] as Id;
    }

    get fixedInstant(): Instant {
      return this._content["fixed"] as Instant;
    }

    get fixedInteger(): Integer {
      return this._content["fixed"] as Integer;
    }

    get fixedMarkdown(): Markdown {
      return this._content["fixed"] as Markdown;
    }

    get fixedOid(): Oid {
      return this._content["fixed"] as Oid;
    }

    get fixedPositiveInt(): PositiveInt {
      return this._content["fixed"] as PositiveInt;
    }

    get fixedString(): String {
      return this._content["fixed"] as String;
    }

    get fixedTime(): Time {
      return this._content["fixed"] as Time;
    }

    get fixedUnsignedInt(): UnsignedInt {
      return this._content["fixed"] as UnsignedInt;
    }

    get fixedUri(): Uri {
      return this._content["fixed"] as Uri;
    }

    get fixedUrl(): Url {
      return this._content["fixed"] as Url;
    }

    get fixedUuid(): Uuid {
      return this._content["fixed"] as Uuid;
    }

    get fixedAddress(): Address {
      return this._content["fixed"] as Address;
    }

    get fixedAge(): Age {
      return this._content["fixed"] as Age;
    }

    get fixedAnnotation(): Annotation {
      return this._content["fixed"] as Annotation;
    }

    get fixedAttachment(): Attachment {
      return this._content["fixed"] as Attachment;
    }

    get fixedCodeableConcept(): CodeableConcept {
      return this._content["fixed"] as CodeableConcept;
    }

    get fixedCodeableReference(): CodeableReference {
      return this._content["fixed"] as CodeableReference;
    }

    get fixedCoding(): Coding {
      return this._content["fixed"] as Coding;
    }

    get fixedContactPoint(): ContactPoint {
      return this._content["fixed"] as ContactPoint;
    }

    get fixedCount(): Count {
      return this._content["fixed"] as Count;
    }

    get fixedDistance(): Distance {
      return this._content["fixed"] as Distance;
    }

    get fixedDuration(): Duration {
      return this._content["fixed"] as Duration;
    }

    get fixedHumanName(): HumanName {
      return this._content["fixed"] as HumanName;
    }

    get fixedIdentifier(): Identifier {
      return this._content["fixed"] as Identifier;
    }

    get fixedMoney(): Money {
      return this._content["fixed"] as Money;
    }

    get fixedPeriod(): Period {
      return this._content["fixed"] as Period;
    }

    get fixedQuantity(): Quantity {
      return this._content["fixed"] as Quantity;
    }

    get fixedRange(): Range {
      return this._content["fixed"] as Range;
    }

    get fixedRatio(): Ratio {
      return this._content["fixed"] as Ratio;
    }

    get fixedRatioRange(): RatioRange {
      return this._content["fixed"] as RatioRange;
    }

    get fixedReference(): Reference {
      return this._content["fixed"] as Reference;
    }

    get fixedSampledData(): SampledData {
      return this._content["fixed"] as SampledData;
    }

    get fixedSignature(): Signature {
      return this._content["fixed"] as Signature;
    }

    get fixedTiming(): Timing {
      return this._content["fixed"] as Timing;
    }

    get fixedContactDetail(): ContactDetail {
      return this._content["fixed"] as ContactDetail;
    }

    get fixedContributor(): Contributor {
      return this._content["fixed"] as Contributor;
    }

    get fixedDataRequirement(): DataRequirement {
      return this._content["fixed"] as DataRequirement;
    }

    get fixedExpression(): Expression {
      return this._content["fixed"] as Expression;
    }

    get fixedParameterDefinition(): ParameterDefinition {
      return this._content["fixed"] as ParameterDefinition;
    }

    get fixedRelatedArtifact(): RelatedArtifact {
      return this._content["fixed"] as RelatedArtifact;
    }

    get fixedTriggerDefinition(): TriggerDefinition {
      return this._content["fixed"] as TriggerDefinition;
    }

    get fixedUsageContext(): UsageContext {
      return this._content["fixed"] as UsageContext;
    }

    get fixedDosage(): Dosage {
      return this._content["fixed"] as Dosage;
    }

    /**
     * If true, the value of this element affects the interpretation of the
     * element or resource that contains it, and the value of the element cannot
     * be ignored. Typically, this is used for status, negation and
     * qualification codes. The effect of this is that the element cannot be
     * ignored by systems: they SHALL either recognize the element and process
     * it, and/or a pre-determination has been made that it is not relevant to
     * their particular system.
     */
    set isModifier(value: Boolean) {
      this._content["isModifier"] = value;
    }

    get isModifier(): Boolean {
      return this._content["isModifier"] as Boolean;
    }

    /**
     * Explains how that element affects the interpretation of the resource or
     * element that contains it.
     */
    set isModifierReason(value: String) {
      this._content["isModifierReason"] = value;
    }

    get isModifierReason(): String {
      return this._content["isModifierReason"] as String;
    }

    /**
     * Whether the element should be included if a client requests a search with
     * the parameter _summary=true.
     */
    set isSummary(value: Boolean) {
      this._content["isSummary"] = value;
    }

    get isSummary(): Boolean {
      return this._content["isSummary"] as Boolean;
    }

    /**
     * A single preferred label which is the text to display beside the element
     * indicating its meaning or to use to prompt for the element in a user
     * display or form.
     */
    set label(value: String) {
      this._content["label"] = value;
    }

    get label(): String {
      return this._content["label"] as String;
    }

    /**
     * Identifies a concept from an external specification that roughly
     * corresponds to this element.
     */
    set mapping(value: Array<Element>) {
      this._content["mapping"] = value;
    }

    get mapping(): Array<Element> {
      return this._content["mapping"] as Array<Element>;
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * instance.
     */
    set max(value: String) {
      this._content["max"] = value;
    }

    get max(): String {
      return this._content["max"] as String;
    }

    /**
     * Indicates the maximum length in characters that is permitted to be
     * present in conformant instances and which is expected to be supported by
     * conformant consumers that support the element.
     */
    set maxLength(value: Integer) {
      this._content["maxLength"] = value;
    }

    get maxLength(): Integer {
      return this._content["maxLength"] as Integer;
    }

    /**
     * The maximum allowed value for the element. The value is inclusive. This
     * is allowed for the types date, dateTime, instant, time, decimal, integer,
     * and Quantity.
     */
    set maxValue(
      value:
        | Date
        | DateTime
        | Instant
        | Time
        | Decimal
        | Integer
        | PositiveInt
        | UnsignedInt
        | Quantity,
    ) {
      this._content["maxValue"] = value;
    }

    get maxValueDate(): Date {
      return this._content["maxValue"] as Date;
    }

    get maxValueDateTime(): DateTime {
      return this._content["maxValue"] as DateTime;
    }

    get maxValueInstant(): Instant {
      return this._content["maxValue"] as Instant;
    }

    get maxValueTime(): Time {
      return this._content["maxValue"] as Time;
    }

    get maxValueDecimal(): Decimal {
      return this._content["maxValue"] as Decimal;
    }

    get maxValueInteger(): Integer {
      return this._content["maxValue"] as Integer;
    }

    get maxValuePositiveInt(): PositiveInt {
      return this._content["maxValue"] as PositiveInt;
    }

    get maxValueUnsignedInt(): UnsignedInt {
      return this._content["maxValue"] as UnsignedInt;
    }

    get maxValueQuantity(): Quantity {
      return this._content["maxValue"] as Quantity;
    }

    /**
     * The Implicit meaning that is to be understood when this element is
     * missing (e.g. 'when this element is missing, the period is ongoing').
     */
    set meaningWhenMissing(value: Markdown) {
      this._content["meaningWhenMissing"] = value;
    }

    get meaningWhenMissing(): Markdown {
      return this._content["meaningWhenMissing"] as Markdown;
    }

    /** The minimum number of times this element SHALL appear in the instance. */
    set min(value: UnsignedInt) {
      this._content["min"] = value;
    }

    get min(): UnsignedInt {
      return this._content["min"] as UnsignedInt;
    }

    /**
     * The minimum allowed value for the element. The value is inclusive. This
     * is allowed for the types date, dateTime, instant, time, decimal, integer,
     * and Quantity.
     */
    set minValue(
      value:
        | Date
        | DateTime
        | Instant
        | Time
        | Decimal
        | Integer
        | PositiveInt
        | UnsignedInt
        | Quantity,
    ) {
      this._content["minValue"] = value;
    }

    get minValueDate(): Date {
      return this._content["minValue"] as Date;
    }

    get minValueDateTime(): DateTime {
      return this._content["minValue"] as DateTime;
    }

    get minValueInstant(): Instant {
      return this._content["minValue"] as Instant;
    }

    get minValueTime(): Time {
      return this._content["minValue"] as Time;
    }

    get minValueDecimal(): Decimal {
      return this._content["minValue"] as Decimal;
    }

    get minValueInteger(): Integer {
      return this._content["minValue"] as Integer;
    }

    get minValuePositiveInt(): PositiveInt {
      return this._content["minValue"] as PositiveInt;
    }

    get minValueUnsignedInt(): UnsignedInt {
      return this._content["minValue"] as UnsignedInt;
    }

    get minValueQuantity(): Quantity {
      return this._content["minValue"] as Quantity;
    }

    /**
     * If true, implementations that produce or consume resources SHALL provide
     * "support" for the element in some meaningful way. If false, the element
     * may be ignored and not supported. If false, whether to populate or use
     * the data element in any way is at the discretion of the implementation.
     */
    set mustSupport(value: Boolean) {
      this._content["mustSupport"] = value;
    }

    get mustSupport(): Boolean {
      return this._content["mustSupport"] as Boolean;
    }

    /**
     * If present, indicates that the order of the repeating element has meaning
     * and describes what that meaning is. If absent, it means that the order of
     * the element has no meaning.
     */
    set orderMeaning(value: String) {
      this._content["orderMeaning"] = value;
    }

    get orderMeaning(): String {
      return this._content["orderMeaning"] as String;
    }

    /**
     * The path identifies the element and is expressed as a "."-separated list
     * of ancestor elements, beginning with the name of the resource or
     * extension.
     */
    set path(value: String) {
      this._content["path"] = value;
    }

    get path(): String {
      return this._content["path"] as String;
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that is,
     * any value in the pattern must be found in the instance. Other additional
     * values may be found too. This is effectively constraint by example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the value
     * provided in the pattern[x] must match the instance value exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each element
     * provided in the pattern[x] array must (recursively) match at least one
     * element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that each
     * property in the pattern must be present in the complex object, and its
     * value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    set pattern(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | Contributor
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Dosage,
    ) {
      this._content["pattern"] = value;
    }

    get patternBase64Binary(): Base64Binary {
      return this._content["pattern"] as Base64Binary;
    }

    get patternBoolean(): Boolean {
      return this._content["pattern"] as Boolean;
    }

    get patternCanonical(): Canonical {
      return this._content["pattern"] as Canonical;
    }

    get patternCode(): Code {
      return this._content["pattern"] as Code;
    }

    get patternDate(): Date {
      return this._content["pattern"] as Date;
    }

    get patternDateTime(): DateTime {
      return this._content["pattern"] as DateTime;
    }

    get patternDecimal(): Decimal {
      return this._content["pattern"] as Decimal;
    }

    get patternId(): Id {
      return this._content["pattern"] as Id;
    }

    get patternInstant(): Instant {
      return this._content["pattern"] as Instant;
    }

    get patternInteger(): Integer {
      return this._content["pattern"] as Integer;
    }

    get patternMarkdown(): Markdown {
      return this._content["pattern"] as Markdown;
    }

    get patternOid(): Oid {
      return this._content["pattern"] as Oid;
    }

    get patternPositiveInt(): PositiveInt {
      return this._content["pattern"] as PositiveInt;
    }

    get patternString(): String {
      return this._content["pattern"] as String;
    }

    get patternTime(): Time {
      return this._content["pattern"] as Time;
    }

    get patternUnsignedInt(): UnsignedInt {
      return this._content["pattern"] as UnsignedInt;
    }

    get patternUri(): Uri {
      return this._content["pattern"] as Uri;
    }

    get patternUrl(): Url {
      return this._content["pattern"] as Url;
    }

    get patternUuid(): Uuid {
      return this._content["pattern"] as Uuid;
    }

    get patternAddress(): Address {
      return this._content["pattern"] as Address;
    }

    get patternAge(): Age {
      return this._content["pattern"] as Age;
    }

    get patternAnnotation(): Annotation {
      return this._content["pattern"] as Annotation;
    }

    get patternAttachment(): Attachment {
      return this._content["pattern"] as Attachment;
    }

    get patternCodeableConcept(): CodeableConcept {
      return this._content["pattern"] as CodeableConcept;
    }

    get patternCodeableReference(): CodeableReference {
      return this._content["pattern"] as CodeableReference;
    }

    get patternCoding(): Coding {
      return this._content["pattern"] as Coding;
    }

    get patternContactPoint(): ContactPoint {
      return this._content["pattern"] as ContactPoint;
    }

    get patternCount(): Count {
      return this._content["pattern"] as Count;
    }

    get patternDistance(): Distance {
      return this._content["pattern"] as Distance;
    }

    get patternDuration(): Duration {
      return this._content["pattern"] as Duration;
    }

    get patternHumanName(): HumanName {
      return this._content["pattern"] as HumanName;
    }

    get patternIdentifier(): Identifier {
      return this._content["pattern"] as Identifier;
    }

    get patternMoney(): Money {
      return this._content["pattern"] as Money;
    }

    get patternPeriod(): Period {
      return this._content["pattern"] as Period;
    }

    get patternQuantity(): Quantity {
      return this._content["pattern"] as Quantity;
    }

    get patternRange(): Range {
      return this._content["pattern"] as Range;
    }

    get patternRatio(): Ratio {
      return this._content["pattern"] as Ratio;
    }

    get patternRatioRange(): RatioRange {
      return this._content["pattern"] as RatioRange;
    }

    get patternReference(): Reference {
      return this._content["pattern"] as Reference;
    }

    get patternSampledData(): SampledData {
      return this._content["pattern"] as SampledData;
    }

    get patternSignature(): Signature {
      return this._content["pattern"] as Signature;
    }

    get patternTiming(): Timing {
      return this._content["pattern"] as Timing;
    }

    get patternContactDetail(): ContactDetail {
      return this._content["pattern"] as ContactDetail;
    }

    get patternContributor(): Contributor {
      return this._content["pattern"] as Contributor;
    }

    get patternDataRequirement(): DataRequirement {
      return this._content["pattern"] as DataRequirement;
    }

    get patternExpression(): Expression {
      return this._content["pattern"] as Expression;
    }

    get patternParameterDefinition(): ParameterDefinition {
      return this._content["pattern"] as ParameterDefinition;
    }

    get patternRelatedArtifact(): RelatedArtifact {
      return this._content["pattern"] as RelatedArtifact;
    }

    get patternTriggerDefinition(): TriggerDefinition {
      return this._content["pattern"] as TriggerDefinition;
    }

    get patternUsageContext(): UsageContext {
      return this._content["pattern"] as UsageContext;
    }

    get patternDosage(): Dosage {
      return this._content["pattern"] as Dosage;
    }

    /**
     * Codes that define how this element is represented in instances, when the
     * deviation varies from the normal case.
     */
    set representation(value: Array<Code>) {
      this._content["representation"] = value;
    }

    get representation(): Array<Code> {
      return this._content["representation"] as Array<Code>;
    }

    /**
     * This element is for traceability of why the element was created and why
     * the constraints exist as they do. This may be used to point to source
     * materials or specifications that drove the structure of this element.
     */
    set requirements(value: Markdown) {
      this._content["requirements"] = value;
    }

    get requirements(): Markdown {
      return this._content["requirements"] as Markdown;
    }

    /**
     * A concise description of what this element means (e.g. for use in
     * autogenerated summaries).
     */
    set short(value: String) {
      this._content["short"] = value;
    }

    get short(): String {
      return this._content["short"] as String;
    }

    /**
     * If true, indicates that this slice definition is constraining a slice
     * definition with the same name in an inherited profile. If false, the
     * slice is not overriding any slice in an inherited profile. If missing,
     * the slice might or might not be overriding a slice in an inherited
     * profile, depending on the sliceName.
     */
    set sliceIsConstraining(value: Boolean) {
      this._content["sliceIsConstraining"] = value;
    }

    get sliceIsConstraining(): Boolean {
      return this._content["sliceIsConstraining"] as Boolean;
    }

    /**
     * The name of this element definition slice, when slicing is working. The
     * name must be a token with no dots or spaces. This is a unique name
     * referring to a specific set of constraints applied to this element, used
     * to provide a name to different slices of the same element.
     */
    set sliceName(value: String) {
      this._content["sliceName"] = value;
    }

    get sliceName(): String {
      return this._content["sliceName"] as String;
    }

    /**
     * Indicates that the element is sliced into a set of alternative
     * definitions (i.e. in a structure definition, there are multiple different
     * constraints on a single element in the base resource). Slicing can be
     * used in any resource that has cardinality ..* on the base resource, or
     * any resource with a choice of types. The set of slices is any elements
     * that come after this in the element sequence that have the same path,
     * until a shorter path occurs (the shorter path terminates the set).
     */
    set slicing(value: Element) {
      this._content["slicing"] = value;
    }

    get slicing(): Element {
      return this._content["slicing"] as Element;
    }

    /**
     * The data type or resource that the value of this element is permitted to
     * be.
     */
    set type(value: Array<Element>) {
      this._content["type"] = value;
    }

    get type(): Array<Element> {
      return this._content["type"] as Array<Element>;
    }
  }

  /**
   * Base StructureDefinition for Expression Type: A expression that is
   * evaluated in a specified context and returns a value. The context of use of
   * the expression must specify the context in which the expression is
   * evaluated, and how the result of the expression is used.
   */
  export class Expression extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Expression";

    /**
     * A brief, natural language description of the condition that effectively
     * communicates the intended semantics.
     */
    set description(value: String) {
      this._content["description"] = value;
    }

    get description(): String {
      return this._content["description"] as String;
    }

    /** An expression in the specified language that returns a value. */
    set expression(value: String) {
      this._content["expression"] = value;
    }

    get expression(): String {
      return this._content["expression"] as String;
    }

    /** The media type of the language for the expression. */
    set language(value: Code) {
      this._content["language"] = value;
    }

    get language(): Code {
      return this._content["language"] as Code;
    }

    /**
     * A short name assigned to the expression to allow for multiple reuse of
     * the expression in the context where it is defined.
     */
    set name(value: Id) {
      this._content["name"] = value;
    }

    get name(): Id {
      return this._content["name"] as Id;
    }

    /** A URI that defines where the expression is found. */
    set reference(value: Uri) {
      this._content["reference"] = value;
    }

    get reference(): Uri {
      return this._content["reference"] as Uri;
    }
  }

  /**
   * Base StructureDefinition for Extension Type: Optional Extension Element -
   * found in all resources.
   */
  export class Extension extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Extension";

    /**
     * Source of the definition for the extension code - a logical name or a
     * URL.
     */
    set url(value: string) {
      this._content["url"] = value;
    }

    get url(): string {
      return this._content["url"] as string;
    }

    /**
     * Value of extension - must be one of a constrained set of the data types
     * (see [Extensibility](extensibility.html) for a list).
     */
    set value(
      value:
        | Base64Binary
        | Boolean
        | Canonical
        | Code
        | Date
        | DateTime
        | Decimal
        | Id
        | Instant
        | Integer
        | Markdown
        | Oid
        | PositiveInt
        | String
        | Time
        | UnsignedInt
        | Uri
        | Url
        | Uuid
        | Address
        | Age
        | Annotation
        | Attachment
        | CodeableConcept
        | CodeableReference
        | Coding
        | ContactPoint
        | Count
        | Distance
        | Duration
        | HumanName
        | Identifier
        | Money
        | Period
        | Quantity
        | Range
        | Ratio
        | RatioRange
        | Reference
        | SampledData
        | Signature
        | Timing
        | ContactDetail
        | Contributor
        | DataRequirement
        | Expression
        | ParameterDefinition
        | RelatedArtifact
        | TriggerDefinition
        | UsageContext
        | Dosage,
    ) {
      this._content["value"] = value;
    }

    get valueBase64Binary(): Base64Binary {
      return this._content["value"] as Base64Binary;
    }

    get valueBoolean(): Boolean {
      return this._content["value"] as Boolean;
    }

    get valueCanonical(): Canonical {
      return this._content["value"] as Canonical;
    }

    get valueCode(): Code {
      return this._content["value"] as Code;
    }

    get valueDate(): Date {
      return this._content["value"] as Date;
    }

    get valueDateTime(): DateTime {
      return this._content["value"] as DateTime;
    }

    get valueDecimal(): Decimal {
      return this._content["value"] as Decimal;
    }

    get valueId(): Id {
      return this._content["value"] as Id;
    }

    get valueInstant(): Instant {
      return this._content["value"] as Instant;
    }

    get valueInteger(): Integer {
      return this._content["value"] as Integer;
    }

    get valueMarkdown(): Markdown {
      return this._content["value"] as Markdown;
    }

    get valueOid(): Oid {
      return this._content["value"] as Oid;
    }

    get valuePositiveInt(): PositiveInt {
      return this._content["value"] as PositiveInt;
    }

    get valueString(): String {
      return this._content["value"] as String;
    }

    get valueTime(): Time {
      return this._content["value"] as Time;
    }

    get valueUnsignedInt(): UnsignedInt {
      return this._content["value"] as UnsignedInt;
    }

    get valueUri(): Uri {
      return this._content["value"] as Uri;
    }

    get valueUrl(): Url {
      return this._content["value"] as Url;
    }

    get valueUuid(): Uuid {
      return this._content["value"] as Uuid;
    }

    get valueAddress(): Address {
      return this._content["value"] as Address;
    }

    get valueAge(): Age {
      return this._content["value"] as Age;
    }

    get valueAnnotation(): Annotation {
      return this._content["value"] as Annotation;
    }

    get valueAttachment(): Attachment {
      return this._content["value"] as Attachment;
    }

    get valueCodeableConcept(): CodeableConcept {
      return this._content["value"] as CodeableConcept;
    }

    get valueCodeableReference(): CodeableReference {
      return this._content["value"] as CodeableReference;
    }

    get valueCoding(): Coding {
      return this._content["value"] as Coding;
    }

    get valueContactPoint(): ContactPoint {
      return this._content["value"] as ContactPoint;
    }

    get valueCount(): Count {
      return this._content["value"] as Count;
    }

    get valueDistance(): Distance {
      return this._content["value"] as Distance;
    }

    get valueDuration(): Duration {
      return this._content["value"] as Duration;
    }

    get valueHumanName(): HumanName {
      return this._content["value"] as HumanName;
    }

    get valueIdentifier(): Identifier {
      return this._content["value"] as Identifier;
    }

    get valueMoney(): Money {
      return this._content["value"] as Money;
    }

    get valuePeriod(): Period {
      return this._content["value"] as Period;
    }

    get valueQuantity(): Quantity {
      return this._content["value"] as Quantity;
    }

    get valueRange(): Range {
      return this._content["value"] as Range;
    }

    get valueRatio(): Ratio {
      return this._content["value"] as Ratio;
    }

    get valueRatioRange(): RatioRange {
      return this._content["value"] as RatioRange;
    }

    get valueReference(): Reference {
      return this._content["value"] as Reference;
    }

    get valueSampledData(): SampledData {
      return this._content["value"] as SampledData;
    }

    get valueSignature(): Signature {
      return this._content["value"] as Signature;
    }

    get valueTiming(): Timing {
      return this._content["value"] as Timing;
    }

    get valueContactDetail(): ContactDetail {
      return this._content["value"] as ContactDetail;
    }

    get valueContributor(): Contributor {
      return this._content["value"] as Contributor;
    }

    get valueDataRequirement(): DataRequirement {
      return this._content["value"] as DataRequirement;
    }

    get valueExpression(): Expression {
      return this._content["value"] as Expression;
    }

    get valueParameterDefinition(): ParameterDefinition {
      return this._content["value"] as ParameterDefinition;
    }

    get valueRelatedArtifact(): RelatedArtifact {
      return this._content["value"] as RelatedArtifact;
    }

    get valueTriggerDefinition(): TriggerDefinition {
      return this._content["value"] as TriggerDefinition;
    }

    get valueUsageContext(): UsageContext {
      return this._content["value"] as UsageContext;
    }

    get valueDosage(): Dosage {
      return this._content["value"] as Dosage;
    }
  }

  /**
   * Base StructureDefinition for HumanName Type: A human's name with the
   * ability to identify parts and usage.
   */
  export class HumanName extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/HumanName";

    /**
     * The part of a name that links to the genealogy. In some cultures (e.g.
     * Eritrea) the family name of a son is the first name of his father.
     */
    set family(value: String) {
      this._content["family"] = value;
    }

    get family(): String {
      return this._content["family"] as String;
    }

    /** Given name. */
    set given(value: Array<String>) {
      this._content["given"] = value;
    }

    get given(): Array<String> {
      return this._content["given"] as Array<String>;
    }

    /**
     * Indicates the period of time when this name was valid for the named
     * person.
     */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Part of the name that is acquired as a title due to academic, legal,
     * employment or nobility status, etc. and that appears at the start of the
     * name.
     */
    set prefix(value: Array<String>) {
      this._content["prefix"] = value;
    }

    get prefix(): Array<String> {
      return this._content["prefix"] as Array<String>;
    }

    /**
     * Part of the name that is acquired as a title due to academic, legal,
     * employment or nobility status, etc. and that appears at the end of the
     * name.
     */
    set suffix(value: Array<String>) {
      this._content["suffix"] = value;
    }

    get suffix(): Array<String> {
      return this._content["suffix"] as Array<String>;
    }

    /**
     * Specifies the entire name as it should be displayed e.g. on an
     * application UI. This may be provided instead of or as well as the
     * specific parts.
     */
    set text(value: String) {
      this._content["text"] = value;
    }

    get text(): String {
      return this._content["text"] as String;
    }

    /** Identifies the purpose for this name. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Base StructureDefinition for Identifier Type: An identifier - identifies
   * some entity uniquely and unambiguously. Typically this is used for business
   * identifiers.
   */
  export class Identifier extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Identifier";

    /** Organization that issued/manages the identifier. */
    set assigner(value: Reference) {
      this._content["assigner"] = value;
    }

    get assigner(): Reference {
      return this._content["assigner"] as Reference;
    }

    /** Time period during which identifier is/was valid for use. */
    set period(value: Period) {
      this._content["period"] = value;
    }

    get period(): Period {
      return this._content["period"] as Period;
    }

    /**
     * Establishes the namespace for the value - that is, a URL that describes a
     * set values that are unique.
     */
    set system(value: Uri) {
      this._content["system"] = value;
    }

    get system(): Uri {
      return this._content["system"] as Uri;
    }

    /**
     * A coded type for the identifier that can be used to determine which
     * identifier to use for a specific purpose.
     */
    set type(value: CodeableConcept) {
      this._content["type"] = value;
    }

    get type(): CodeableConcept {
      return this._content["type"] as CodeableConcept;
    }

    /** The purpose of this identifier. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }

    /**
     * The portion of the identifier typically relevant to the user and which is
     * unique within the context of the system.
     */
    set value(value: String) {
      this._content["value"] = value;
    }

    get value(): String {
      return this._content["value"] as String;
    }
  }

  /**
   * Base StructureDefinition for MarketingStatus Type: The marketing status
   * describes the date when a medicinal product is actually put on the market
   * or the date as of which it is no longer available.
   */
  export class MarketingStatus extends BackboneElement {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MarketingStatus";

    /**
     * The country in which the marketing authorisation has been granted shall
     * be specified It should be specified using the ISO 3166  1 alpha-2 code
     * elements.
     */
    set country(value: CodeableConcept) {
      this._content["country"] = value;
    }

    get country(): CodeableConcept {
      return this._content["country"] as CodeableConcept;
    }

    /**
     * The date when the Medicinal Product is placed on the market by the
     * Marketing Authorisation Holder (or where applicable, the
     * manufacturer/distributor) in a country and/or jurisdiction shall be
     * provided A complete date consisting of day, month and year shall be
     * specified using the ISO 8601 date format NOTE Placed on the market
     * refers to the release of the Medicinal Product into the distribution
     * chain.
     */
    set dateRange(value: Period) {
      this._content["dateRange"] = value;
    }

    get dateRange(): Period {
      return this._content["dateRange"] as Period;
    }

    /**
     * Where a Medicines Regulatory Agency has granted a marketing authorisation
     * for which specific provisions within a jurisdiction apply, the
     * jurisdiction can be specified using an appropriate controlled terminology
     * The controlled term and the controlled term identifier shall be
     * specified.
     */
    set jurisdiction(value: CodeableConcept) {
      this._content["jurisdiction"] = value;
    }

    get jurisdiction(): CodeableConcept {
      return this._content["jurisdiction"] as CodeableConcept;
    }

    /**
     * The date when the Medicinal Product is placed on the market by the
     * Marketing Authorisation Holder (or where applicable, the
     * manufacturer/distributor) in a country and/or jurisdiction shall be
     * provided A complete date consisting of day, month and year shall be
     * specified using the ISO 8601 date format NOTE Placed on the market
     * refers to the release of the Medicinal Product into the distribution
     * chain.
     */
    set restoreDate(value: DateTime) {
      this._content["restoreDate"] = value;
    }

    get restoreDate(): DateTime {
      return this._content["restoreDate"] as DateTime;
    }

    /**
     * This attribute provides information on the status of the marketing of the
     * medicinal product See ISO/TS 20443 for more information and examples.
     */
    set status(value: CodeableConcept) {
      this._content["status"] = value;
    }

    get status(): CodeableConcept {
      return this._content["status"] as CodeableConcept;
    }
  }

  /**
   * Base StructureDefinition for Meta Type: The metadata about a resource. This
   * is content in the resource that is maintained by the infrastructure.
   * Changes to the content might not always be associated with version changes
   * to the resource.
   */
  export class Meta extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Meta";

    /** When the resource last changed - e.g. when the version changed. */
    set lastUpdated(value: Instant) {
      this._content["lastUpdated"] = value;
    }

    get lastUpdated(): Instant {
      return this._content["lastUpdated"] as Instant;
    }

    /**
     * A list of profiles (references to
     * [StructureDefinition](structuredefinition.html#) resources) that this
     * resource claims to conform to. The URL is a reference to
     * [StructureDefinition.url](structuredefinition-definitions.html#StructureDefinition.url).
     */
    set profile(value: Array<Canonical>) {
      this._content["profile"] = value;
    }

    get profile(): Array<Canonical> {
      return this._content["profile"] as Array<Canonical>;
    }

    /**
     * Security labels applied to this resource. These tags connect specific
     * resources to the overall security policy and infrastructure.
     */
    set security(value: Array<Coding>) {
      this._content["security"] = value;
    }

    get security(): Array<Coding> {
      return this._content["security"] as Array<Coding>;
    }

    /**
     * A uri that identifies the source system of the resource. This provides a
     * minimal amount of [Provenance](provenance.html#) information that can be
     * used to track or differentiate the source of information in the resource.
     * The source may identify another FHIR server, document, message, database,
     * etc.
     */
    set source(value: Uri) {
      this._content["source"] = value;
    }

    get source(): Uri {
      return this._content["source"] as Uri;
    }

    /**
     * Tags applied to this resource. Tags are intended to be used to identify
     * and relate resources to process and workflow, and applications are not
     * required to consider the tags when interpreting the meaning of a
     * resource.
     */
    set tag(value: Array<Coding>) {
      this._content["tag"] = value;
    }

    get tag(): Array<Coding> {
      return this._content["tag"] as Array<Coding>;
    }

    /**
     * The version specific identifier, as it appears in the version portion of
     * the URL. This value changes when the resource is created, updated, or
     * deleted.
     */
    set versionId(value: Id) {
      this._content["versionId"] = value;
    }

    get versionId(): Id {
      return this._content["versionId"] as Id;
    }
  }

  /**
   * Base StructureDefinition for Money Type: An amount of economic utility in
   * some recognized currency.
   */
  export class Money extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Money";

    /** ISO 4217 Currency Code. */
    set currency(value: Code) {
      this._content["currency"] = value;
    }

    get currency(): Code {
      return this._content["currency"] as Code;
    }

    /** Numerical value (with implicit precision). */
    set value(value: Decimal) {
      this._content["value"] = value;
    }

    get value(): Decimal {
      return this._content["value"] as Decimal;
    }
  }

  /**
   * Base StructureDefinition for Narrative Type: A human-readable summary of
   * the resource conveying the essential clinical and business information for
   * the resource.
   */
  export class Narrative extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Narrative";

    /** The actual narrative content, a stripped down version of XHTML. */
    set div(value: Xhtml) {
      this._content["div"] = value;
    }

    get div(): Xhtml {
      return this._content["div"] as Xhtml;
    }

    /**
     * The status of the narrative - whether it's entirely generated (from just
     * the defined data or the extensions too), or whether a human authored it
     * and it may contain additional data.
     */
    set status(value: Code) {
      this._content["status"] = value;
    }

    get status(): Code {
      return this._content["status"] as Code;
    }
  }

  /**
   * Base StructureDefinition for ParameterDefinition Type: The parameters to
   * the module. This collection specifies both the input and output parameters.
   * Input parameters are provided by the caller as part of the $evaluate
   * operation. Output parameters are included in the GuidanceResponse.
   */
  export class ParameterDefinition extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ParameterDefinition";

    /**
     * A brief discussion of what the parameter is for and how it is used by the
     * module.
     */
    set documentation(value: String) {
      this._content["documentation"] = value;
    }

    get documentation(): String {
      return this._content["documentation"] as String;
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * request or response.
     */
    set max(value: String) {
      this._content["max"] = value;
    }

    get max(): String {
      return this._content["max"] as String;
    }

    /**
     * The minimum number of times this parameter SHALL appear in the request or
     * response.
     */
    set min(value: Integer) {
      this._content["min"] = value;
    }

    get min(): Integer {
      return this._content["min"] as Integer;
    }

    /**
     * The name of the parameter used to allow access to the value of the
     * parameter in evaluation contexts.
     */
    set name(value: Code) {
      this._content["name"] = value;
    }

    get name(): Code {
      return this._content["name"] as Code;
    }

    /**
     * If specified, this indicates a profile that the input data must conform
     * to, or that the output data will conform to.
     */
    set profile(value: Canonical) {
      this._content["profile"] = value;
    }

    get profile(): Canonical {
      return this._content["profile"] as Canonical;
    }

    /** The type of the parameter. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /** Whether the parameter is input or output for the module. */
    set use(value: Code) {
      this._content["use"] = value;
    }

    get use(): Code {
      return this._content["use"] as Code;
    }
  }

  /**
   * Base StructureDefinition for Period Type: A time period defined by a start
   * and end date and optionally time.
   */
  export class Period extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Period";

    /**
     * The end of the period. If the end of the period is missing, it means no
     * end was known or planned at the time the instance was created. The start
     * may be in the past, and the end date in the future, which means that
     * period is expected/planned to end at that time.
     */
    set end(value: DateTime) {
      this._content["end"] = value;
    }

    get end(): DateTime {
      return this._content["end"] as DateTime;
    }

    /** The start of the period. The boundary is inclusive. */
    set start(value: DateTime) {
      this._content["start"] = value;
    }

    get start(): DateTime {
      return this._content["start"] as DateTime;
    }
  }

  /**
   * Base StructureDefinition for Population Type: A populatioof people with
   * some set of grouping criteria.
   */
  export class Population extends BackboneElement {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Population";

    /** The age of the specific population. */
    set age(value: Range | CodeableConcept) {
      this._content["age"] = value;
    }

    get ageRange(): Range {
      return this._content["age"] as Range;
    }

    get ageCodeableConcept(): CodeableConcept {
      return this._content["age"] as CodeableConcept;
    }

    /** The gender of the specific population. */
    set gender(value: CodeableConcept) {
      this._content["gender"] = value;
    }

    get gender(): CodeableConcept {
      return this._content["gender"] as CodeableConcept;
    }

    /**
     * The existing physiological conditions of the specific population to which
     * this applies.
     */
    set physiologicalCondition(value: CodeableConcept) {
      this._content["physiologicalCondition"] = value;
    }

    get physiologicalCondition(): CodeableConcept {
      return this._content["physiologicalCondition"] as CodeableConcept;
    }

    /** Race of the specific population. */
    set race(value: CodeableConcept) {
      this._content["race"] = value;
    }

    get race(): CodeableConcept {
      return this._content["race"] as CodeableConcept;
    }
  }

  /**
   * Base StructureDefinition for ProdCharacteristic Type: The marketing status
   * describes the date when a medicinal product is actually put on the market
   * or the date as of which it is no longer available.
   */
  export class ProdCharacteristic extends BackboneElement {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ProdCharacteristic";

    /**
     * Where applicable, the color can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be used.
     */
    set color(value: Array<String>) {
      this._content["color"] = value;
    }

    get color(): Array<String> {
      return this._content["color"] as Array<String>;
    }

    /**
     * Where applicable, the depth can be specified using a numerical value and
     * its unit of measurement The unit of measurement shall be specified in
     * accordance with ISO 11240 and the resulting terminology The symbol and
     * the symbol identifier shall be used.
     */
    set depth(value: Quantity) {
      this._content["depth"] = value;
    }

    get depth(): Quantity {
      return this._content["depth"] as Quantity;
    }

    /**
     * Where applicable, the external diameter can be specified using a
     * numerical value and its unit of measurement The unit of measurement shall
     * be specified in accordance with ISO 11240 and the resulting terminology
     * The symbol and the symbol identifier shall be used.
     */
    set externalDiameter(value: Quantity) {
      this._content["externalDiameter"] = value;
    }

    get externalDiameter(): Quantity {
      return this._content["externalDiameter"] as Quantity;
    }

    /**
     * Where applicable, the height can be specified using a numerical value and
     * its unit of measurement The unit of measurement shall be specified in
     * accordance with ISO 11240 and the resulting terminology The symbol and
     * the symbol identifier shall be used.
     */
    set height(value: Quantity) {
      this._content["height"] = value;
    }

    get height(): Quantity {
      return this._content["height"] as Quantity;
    }

    /**
     * Where applicable, the image can be provided The format of the image
     * attachment shall be specified by regional implementations.
     */
    set image(value: Array<Attachment>) {
      this._content["image"] = value;
    }

    get image(): Array<Attachment> {
      return this._content["image"] as Array<Attachment>;
    }

    /** Where applicable, the imprint can be specified as text. */
    set imprint(value: Array<String>) {
      this._content["imprint"] = value;
    }

    get imprint(): Array<String> {
      return this._content["imprint"] as Array<String>;
    }

    /**
     * Where applicable, the nominal volume can be specified using a numerical
     * value and its unit of measurement The unit of measurement shall be
     * specified in accordance with ISO 11240 and the resulting terminology The
     * symbol and the symbol identifier shall be used.
     */
    set nominalVolume(value: Quantity) {
      this._content["nominalVolume"] = value;
    }

    get nominalVolume(): Quantity {
      return this._content["nominalVolume"] as Quantity;
    }

    /**
     * Where applicable, the scoring can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be used.
     */
    set scoring(value: CodeableConcept) {
      this._content["scoring"] = value;
    }

    get scoring(): CodeableConcept {
      return this._content["scoring"] as CodeableConcept;
    }

    /**
     * Where applicable, the shape can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be used.
     */
    set shape(value: String) {
      this._content["shape"] = value;
    }

    get shape(): String {
      return this._content["shape"] as String;
    }

    /**
     * Where applicable, the weight can be specified using a numerical value and
     * its unit of measurement The unit of measurement shall be specified in
     * accordance with ISO 11240 and the resulting terminology The symbol and
     * the symbol identifier shall be used.
     */
    set weight(value: Quantity) {
      this._content["weight"] = value;
    }

    get weight(): Quantity {
      return this._content["weight"] as Quantity;
    }

    /**
     * Where applicable, the width can be specified using a numerical value and
     * its unit of measurement The unit of measurement shall be specified in
     * accordance with ISO 11240 and the resulting terminology The symbol and
     * the symbol identifier shall be used.
     */
    set width(value: Quantity) {
      this._content["width"] = value;
    }

    get width(): Quantity {
      return this._content["width"] as Quantity;
    }
  }

  /**
   * Base StructureDefinition for ProductShelfLife Type: The shelf-life and
   * storage information for a medicinal product item or container can be
   * described using this class.
   */
  export class ProductShelfLife extends BackboneElement {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/ProductShelfLife";

    /** Unique identifier for the packaged Medicinal Product. */
    set identifier(value: Identifier) {
      this._content["identifier"] = value;
    }

    get identifier(): Identifier {
      return this._content["identifier"] as Identifier;
    }

    /**
     * The shelf life time period can be specified using a numerical value for
     * the period of time and its unit of time measurement The unit of
     * measurement shall be specified in accordance with ISO 11240 and the
     * resulting terminology The symbol and the symbol identifier shall be
     * used.
     */
    set period(value: Quantity) {
      this._content["period"] = value;
    }

    get period(): Quantity {
      return this._content["period"] as Quantity;
    }

    /**
     * Special precautions for storage, if any, can be specified using an
     * appropriate controlled vocabulary The controlled term and the controlled
     * term identifier shall be specified.
     */
    set specialPrecautionsForStorage(value: Array<CodeableConcept>) {
      this._content["specialPrecautionsForStorage"] = value;
    }

    get specialPrecautionsForStorage(): Array<CodeableConcept> {
      return this._content[
        "specialPrecautionsForStorage"
      ] as Array<CodeableConcept>;
    }

    /**
     * This describes the shelf life, taking into account various scenarios such
     * as shelf life of the packaged Medicinal Product itself, shelf life after
     * transformation where necessary and shelf life after the first opening of
     * a bottle, etc. The shelf life type shall be specified using an
     * appropriate controlled vocabulary The controlled term and the controlled
     * term identifier shall be specified.
     */
    set type(value: CodeableConcept) {
      this._content["type"] = value;
    }

    get type(): CodeableConcept {
      return this._content["type"] as CodeableConcept;
    }
  }

  /**
   * Base StructureDefinition for Range Type: A set of ordered Quantities
   * defined by a low and high limit.
   */
  export class Range extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Range";

    /** The high limit. The boundary is inclusive. */
    set high(value: Quantity) {
      this._content["high"] = value;
    }

    get high(): Quantity {
      return this._content["high"] as Quantity;
    }

    /** The low limit. The boundary is inclusive. */
    set low(value: Quantity) {
      this._content["low"] = value;
    }

    get low(): Quantity {
      return this._content["low"] as Quantity;
    }
  }

  /**
   * Base StructureDefinition for Ratio Type: A relationship of two Quantity
   * values - expressed as a numerator and a denominator.
   */
  export class Ratio extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Ratio";

    /** The value of the denominator. */
    set denominator(value: Quantity) {
      this._content["denominator"] = value;
    }

    get denominator(): Quantity {
      return this._content["denominator"] as Quantity;
    }

    /** The value of the numerator. */
    set numerator(value: Quantity) {
      this._content["numerator"] = value;
    }

    get numerator(): Quantity {
      return this._content["numerator"] as Quantity;
    }
  }

  /**
   * Base StructureDefinition for RatioRange Type: A range of ratios expressed
   * as a low and high numerator and a denominator.
   */
  export class RatioRange extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/RatioRange";

    /** The value of the denominator. */
    set denominator(value: Quantity) {
      this._content["denominator"] = value;
    }

    get denominator(): Quantity {
      return this._content["denominator"] as Quantity;
    }

    /** The value of the high limit numerator. */
    set highNumerator(value: Quantity) {
      this._content["highNumerator"] = value;
    }

    get highNumerator(): Quantity {
      return this._content["highNumerator"] as Quantity;
    }

    /** The value of the low limit numerator. */
    set lowNumerator(value: Quantity) {
      this._content["lowNumerator"] = value;
    }

    get lowNumerator(): Quantity {
      return this._content["lowNumerator"] as Quantity;
    }
  }

  /**
   * Base StructureDefinition for Reference Type: A reference from one resource
   * to another.
   */
  export class Reference extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Reference";

    /**
     * Plain text narrative that identifies the resource in addition to the
     * resource reference.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * An identifier for the target resource. This is used when there is no way
     * to reference the other resource directly, either because the entity it
     * represents is not available through a FHIR server, or because there is no
     * way for the author of the resource to convert a known identifier to an
     * actual location. There is no requirement that a Reference.identifier
     * point to something that is actually exposed as a FHIR instance, but it
     * SHALL point to a business concept that would be expected to be exposed as
     * a FHIR instance, and that instance would need to be of a FHIR resource
     * type allowed by the reference.
     */
    set identifier(value: Identifier) {
      this._content["identifier"] = value;
    }

    get identifier(): Identifier {
      return this._content["identifier"] as Identifier;
    }

    /**
     * A reference to a location at which the other resource is found. The
     * reference may be a relative reference, in which case it is relative to
     * the service base URL, or an absolute URL that resolves to the location
     * where the resource is found. The reference may be version specific or
     * not. If the reference is not to a FHIR RESTful server, then it should be
     * assumed to be version specific. Internal fragment references (start with
     * '#') refer to contained resources.
     */
    set reference(value: String) {
      this._content["reference"] = value;
    }

    get reference(): String {
      return this._content["reference"] as String;
    }

    /**
     * The expected type of the target of the reference. If both Reference.type
     * and Reference.reference are populated and Reference.reference is a FHIR
     * URL, both SHALL be consistent.
     *
     * The type is the Canonical URL of Resource Definition that is the type
     * this reference refers to. References are URLs that are relative to
     * http://hl7.org/fhir/StructureDefinition/ e.g. "Patient" is a reference to
     * http://hl7.org/fhir/StructureDefinition/Patient. Absolute URLs are only
     * allowed for logical models (and can only be used in references in logical
     * models, not resources).
     */
    set type(value: Uri) {
      this._content["type"] = value;
    }

    get type(): Uri {
      return this._content["type"] as Uri;
    }
  }

  /**
   * Base StructureDefinition for RelatedArtifact Type: Related artifacts such
   * as additional documentation, justification, or bibliographic references.
   */
  export class RelatedArtifact extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/RelatedArtifact";

    /**
     * A bibliographic citation for the related artifact. This text SHOULD be
     * formatted according to an accepted citation format.
     */
    set citation(value: Markdown) {
      this._content["citation"] = value;
    }

    get citation(): Markdown {
      return this._content["citation"] as Markdown;
    }

    /**
     * A brief description of the document or knowledge resource being
     * referenced, suitable for display to a consumer.
     */
    set display(value: String) {
      this._content["display"] = value;
    }

    get display(): String {
      return this._content["display"] as String;
    }

    /**
     * The document being referenced, represented as an attachment. This is
     * exclusive with the resource element.
     */
    set document(value: Attachment) {
      this._content["document"] = value;
    }

    get document(): Attachment {
      return this._content["document"] as Attachment;
    }

    /**
     * A short label that can be used to reference the citation from elsewhere
     * in the containing artifact, such as a footnote index.
     */
    set label(value: String) {
      this._content["label"] = value;
    }

    get label(): String {
      return this._content["label"] as String;
    }

    /**
     * The related resource, such as a library, value set, profile, or other
     * knowledge resource.
     */
    set resource(value: Canonical) {
      this._content["resource"] = value;
    }

    get resource(): Canonical {
      return this._content["resource"] as Canonical;
    }

    /** The type of relationship to the related artifact. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }

    /** A url for the artifact that can be followed to access the actual content. */
    set url(value: Url) {
      this._content["url"] = value;
    }

    get url(): Url {
      return this._content["url"] as Url;
    }
  }

  /**
   * Base StructureDefinition for SampledData Type: A series of measurements
   * taken by a device, with upper and lower limits. There may be more than one
   * dimension in the data.
   */
  export class SampledData extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/SampledData";

    /**
     * A series of data points which are decimal values separated by a single
     * space (character u20). The special values "E" (error), "L" (below
     * detection limit) and "U" (above detection limit) can also be used in
     * place of a decimal value.
     */
    set data(value: String) {
      this._content["data"] = value;
    }

    get data(): String {
      return this._content["data"] as String;
    }

    /**
     * The number of sample points at each time point. If this value is greater
     * than one, then the dimensions will be interlaced - all the sample points
     * for a point in time will be recorded at once.
     */
    set dimensions(value: PositiveInt) {
      this._content["dimensions"] = value;
    }

    get dimensions(): PositiveInt {
      return this._content["dimensions"] as PositiveInt;
    }

    /**
     * A correction factor that is applied to the sampled data points before
     * they are added to the origin.
     */
    set factor(value: Decimal) {
      this._content["factor"] = value;
    }

    get factor(): Decimal {
      return this._content["factor"] as Decimal;
    }

    /**
     * The lower limit of detection of the measured points. This is needed if
     * any of the data points have the value "L" (lower than detection limit).
     */
    set lowerLimit(value: Decimal) {
      this._content["lowerLimit"] = value;
    }

    get lowerLimit(): Decimal {
      return this._content["lowerLimit"] as Decimal;
    }

    /**
     * The base quantity that a measured value of zero represents. In addition,
     * this provides the units of the entire measurement series.
     */
    set origin(value: Quantity) {
      this._content["origin"] = value;
    }

    get origin(): Quantity {
      return this._content["origin"] as Quantity;
    }

    /** The length of time between sampling times, measured in milliseconds. */
    set period(value: Decimal) {
      this._content["period"] = value;
    }

    get period(): Decimal {
      return this._content["period"] as Decimal;
    }

    /**
     * The upper limit of detection of the measured points. This is needed if
     * any of the data points have the value "U" (higher than detection limit).
     */
    set upperLimit(value: Decimal) {
      this._content["upperLimit"] = value;
    }

    get upperLimit(): Decimal {
      return this._content["upperLimit"] as Decimal;
    }
  }

  /**
   * Base StructureDefinition for Signature Type: A signature along with
   * supporting context. The signature may be a digital signature that is
   * cryptographic in nature, or some other signature acceptable to the domain.
   * This other signature may be as simple as a graphical image representing a
   * hand-written signature, or a signature ceremony Different signature
   * approaches have different utilities.
   */
  export class Signature extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Signature";

    /**
     * The base64 encoding of the Signature content. When signature is not
     * recorded electronically this element would be empty.
     */
    set data(value: Base64Binary) {
      this._content["data"] = value;
    }

    get data(): Base64Binary {
      return this._content["data"] as Base64Binary;
    }

    /**
     * A reference to an application-usable description of the identity that is
     * represented by the signature.
     */
    set onBehalfOf(value: Reference) {
      this._content["onBehalfOf"] = value;
    }

    get onBehalfOf(): Reference {
      return this._content["onBehalfOf"] as Reference;
    }

    /**
     * A mime type that indicates the technical format of the signature.
     * Important mime types are application/signature+xml for X ML DigSig,
     * application/jose for JWS, and image/* for a graphical image of a
     * signature, etc.
     */
    set sigFormat(value: Code) {
      this._content["sigFormat"] = value;
    }

    get sigFormat(): Code {
      return this._content["sigFormat"] as Code;
    }

    /**
     * A mime type that indicates the technical format of the target resources
     * signed by the signature.
     */
    set targetFormat(value: Code) {
      this._content["targetFormat"] = value;
    }

    get targetFormat(): Code {
      return this._content["targetFormat"] as Code;
    }

    /**
     * An indication of the reason that the entity signed this document. This
     * may be explicitly included as part of the signature information and can
     * be used when determining accountability for various actions concerning
     * the document.
     */
    set type(value: Array<Coding>) {
      this._content["type"] = value;
    }

    get type(): Array<Coding> {
      return this._content["type"] as Array<Coding>;
    }

    /** When the digital signature was signed. */
    set when(value: Instant) {
      this._content["when"] = value;
    }

    get when(): Instant {
      return this._content["when"] as Instant;
    }

    /**
     * A reference to an application-usable description of the identity that
     * signed (e.g. the signature used their private key).
     */
    set who(value: Reference) {
      this._content["who"] = value;
    }

    get who(): Reference {
      return this._content["who"] as Reference;
    }
  }

  /**
   * Base StructureDefinition for Timing Type: Specifies an event that may occur
   * multiple times. Timing schedules are used to record when things are
   * planned, expected or requested to occur. The most common usage is in dosage
   * instructions for medications. They are also used when planning care of
   * various kinds, and may be used for reporting the schedule to which past
   * regular activities were carried out.
   */
  export class Timing extends BackboneElement {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Timing";

    /**
     * A code for the timing schedule (or just text in code.text). Some codes
     * such as BID are ubiquitous, but many institutions define their own
     * additional codes. If a code is provided, the code is understood to be a
     * complete statement of whatever is specified in the structured timing
     * data, and either the code or the data may be used to interpret the
     * Timing, with the exception that .repeat.bounds still applies over the
     * code (and is not contained in the code).
     */
    set code(value: CodeableConcept) {
      this._content["code"] = value;
    }

    get code(): CodeableConcept {
      return this._content["code"] as CodeableConcept;
    }

    /** Identifies specific times when the event occurs. */
    set event(value: Array<DateTime>) {
      this._content["event"] = value;
    }

    get event(): Array<DateTime> {
      return this._content["event"] as Array<DateTime>;
    }

    /** A set of rules that describe when the event is scheduled. */
    set repeat(value: Element) {
      this._content["repeat"] = value;
    }

    get repeat(): Element {
      return this._content["repeat"] as Element;
    }
  }

  /**
   * Base StructureDefinition for TriggerDefinition Type: A description of a
   * triggering event. Triggering events can be named events, data events, or
   * periodic, as determined by the type element.
   */
  export class TriggerDefinition extends Element {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/TriggerDefinition";

    /**
     * A boolean-valued expression that is evaluated in the context of the
     * container of the trigger definition and returns whether or not the
     * trigger fires.
     */
    set condition(value: Expression) {
      this._content["condition"] = value;
    }

    get condition(): Expression {
      return this._content["condition"] as Expression;
    }

    /**
     * The triggering data of the event (if this is a data trigger). If more
     * than one data is requirement is specified, then all the data requirements
     * must be true.
     */
    set data(value: Array<DataRequirement>) {
      this._content["data"] = value;
    }

    get data(): Array<DataRequirement> {
      return this._content["data"] as Array<DataRequirement>;
    }

    /**
     * A formal name for the event. This may be an absolute URI that identifies
     * the event formally (e.g. from a trigger registry), or a simple relative
     * URI that identifies the event in a local context.
     */
    set name(value: String) {
      this._content["name"] = value;
    }

    get name(): String {
      return this._content["name"] as String;
    }

    /** The timing of the event (if this is a periodic trigger). */
    set timing(value: Timing | Reference | Date | DateTime) {
      this._content["timing"] = value;
    }

    get timingTiming(): Timing {
      return this._content["timing"] as Timing;
    }

    get timingReference(): Reference {
      return this._content["timing"] as Reference;
    }

    get timingDate(): Date {
      return this._content["timing"] as Date;
    }

    get timingDateTime(): DateTime {
      return this._content["timing"] as DateTime;
    }

    /** The type of triggering event. */
    set type(value: Code) {
      this._content["type"] = value;
    }

    get type(): Code {
      return this._content["type"] as Code;
    }
  }

  /**
   * Base StructureDefinition for UsageContext Type: Specifies
   * clinical/business/etc. metadata that can be used to retrieve, index and/or
   * categorize an artifact. This metadata can either be specific to the
   * applicable population (e.g., age category, DRG) or the specific context of
   * care (e.g., venue, care setting, provider of care).
   */
  export class UsageContext extends Element {
    static url: string = "http://hl7.org/fhir/StructureDefinition/UsageContext";

    /**
     * A code that identifies the type of context being specified by this usage
     * context.
     */
    set code(value: Coding) {
      this._content["code"] = value;
    }

    get code(): Coding {
      return this._content["code"] as Coding;
    }

    /**
     * A value that defines the context specified in this context of use. The
     * interpretation of the value is defined by the code.
     */
    set value(value: CodeableConcept | Quantity | Range | Reference) {
      this._content["value"] = value;
    }

    get valueCodeableConcept(): CodeableConcept {
      return this._content["value"] as CodeableConcept;
    }

    get valueQuantity(): Quantity {
      return this._content["value"] as Quantity;
    }

    get valueRange(): Range {
      return this._content["value"] as Range;
    }

    get valueReference(): Reference {
      return this._content["value"] as Reference;
    }
  }

  /**
   * An amount of money. With regard to precision, see [Decimal
   * Precision](datatypes.html#precision)
   */
  export class MoneyQuantity extends Quantity {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/MoneyQuantity";
  }

  /** A fixed quantity (no comparator) */
  export class SimpleQuantity extends Quantity {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/SimpleQuantity";
  }

  export class Base {
    static url: string = "http://hl7.org/fhir/StructureDefinition/Element/Base";
  }

  export class DataType {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/Element/DataType";
  }

  export class Resource {
    static url: string =
      "http://hl7.org/fhir/StructureDefinition/Element/Resource";
  }
}
